commit d13c4b3ab7fc36be47177fbe3c18e93833409567
Author: simeydotme <simey.me@gmail.com>
Date:   Thu Apr 3 20:09:41 2025 +0800

    check for min/max as NaN or Infinity
    
    - edge case sanitization
    - if somehow the min/max were set as NaN or Infinity, then we need to
    fix that else the browser crashes

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 153ae84..de34d3c 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -4,6 +4,7 @@
   import { type SpringOpts, type Spring, spring as springStore } from 'svelte/motion';
   import { createEventDispatcher, onMount } from 'svelte';
   import {
+    isFiniteNumber,
     coerceFloat,
     valueAsPercent,
     clampValue,
@@ -108,6 +109,24 @@
     }
   };
 
+  const checkMinMax = () => {
+    if (!isFiniteNumber(min)) {
+      min = 0;
+      console.error("'min' prop must be a valid finite number");
+    }
+    if (!isFiniteNumber(max)) {
+      max = 100;
+      console.error("'max' prop must be a valid finite number");
+    }
+    if (min >= max) {
+      min = 0;
+      max = 100;
+      console.error("'min' prop should be less than 'max'");
+    }
+    min = coerceFloat(min, precision);
+    max = coerceFloat(max, precision);
+  };
+
   const checkValueIsNumber = () => {
     if (typeof value !== 'number') {
       value = (max + min) / 2;
@@ -122,14 +141,6 @@
     }
   };
 
-  const checkMinMax = () => {
-    if (min >= max) {
-      min = 0;
-      max = 100;
-      console.error("'min' prop should be less than 'max'");
-    }
-  };
-
   const checkAriaLabels = () => {
     if (values.length > 1 && !Array.isArray(ariaLabels)) {
       ariaLabels = [];
@@ -172,10 +183,10 @@
   };
 
   // fixup the value/values at render
+  checkMinMax();
   checkValueIsNumber();
   checkValuesIsArray();
   checkValuesAgainstRangeGaps();
-  checkMinMax();
   checkFormatters();
 
   // keep value and values in sync with each other

commit b5b54ac98968724efe1f68fbde503bebe8566305
Author: simeydotme <simey.me@gmail.com>
Date:   Tue Apr 1 17:56:33 2025 +0800

    fix transform visual bug for floats

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 62e8678..153ae84 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -1124,14 +1124,14 @@
     bottom: auto;
     left: auto;
     right: 1.75em;
-    transform: translate(-50%, -50%);
+    translate: -50% -50% 0.01px;
   }
 
   :global(.rangeSlider.rsVertical .rangeHandle.rsActive .rangeFloat),
   :global(.rangeSlider.rsVertical.rsHoverable .rangeHandle:hover .rangeFloat),
   :global(.rangeSlider.rsVertical.rsHoverable .rangeBar:hover .rangeFloat),
   :global(.rangeSlider.rsVertical.rsFocus .rangeBar .rangeFloat) {
-    transform: translate(0%, -50%);
+    translate: 0% -50% 0.01px;
   }
 
   :global(.rangeSlider.rsVertical .rangeBar .rangeFloat) {

commit f13d9935c46d8ba4d1588c5cfb9b55643795e065
Author: simeydotme <simey.me@gmail.com>
Date:   Tue Apr 1 17:47:21 2025 +0800

    add tests for steps, add 'data-index' prop for pips
    
    - found a bug in rangePips which was not setting the correct 'pipCount'
            - so refactored the code for that a little bit
            - also added 'data-index' for each pip for easier access in
    css/js

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index 485891a..f08fa8b 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -45,12 +45,33 @@
 
   let clientStart: null | NormalisedClient = null;
 
+  // by default we would like to show maximum of 50 pips vertically and 100 horizontally
   $: stepMax = vertical ? 50 : 100;
-  $: tooManyPips = (max - min) / step >= stepMax;
-  $: stepDivisor = vertical ? 10 : 20;
-  $: reducedSteps = (max - min) / stepDivisor;
-  $: pipStep = pipstep ?? (tooManyPips ? reducedSteps : 1);
-  $: pipCount = Math.floor((max - min) / (step * pipStep));
+  // track if the amount of steps calculated is greater than the max we'd like to show
+  $: tooManySteps = (max - min) / step >= stepMax;
+
+  // track the number of pips we're actually going to render
+  let pipCount = 0;
+  // track the final pipstep we're going to use
+  let finalPipStep = 1;
+
+  $: {
+    // if no pipstep is provided, we use a sensible default (respecting the stepMax check)
+    finalPipStep = pipstep ?? (tooManySteps ? (max - min) / (stepMax / 5) : 1);
+    pipCount = Math.ceil((max - min) / (step * finalPipStep));
+    // there's no way a browser can render over 1000 pips without performance issues,
+    // so we should limit and warn the user if they're trying to render too many
+    if (pipCount > 1000) {
+      console.warn(
+        'RangePips: You are trying to render too many pips. This will cause performance issues. Try increasing the "pipstep" prop to reduce the number of pips shown.'
+      );
+      // start increasing the finalPipStep until we get a pipCountbelow 1000
+      while (pipCount >= 1000) {
+        finalPipStep = finalPipStep + finalPipStep;
+        pipCount = Math.ceil((max - min) / (step * finalPipStep));
+      }
+    }
+  }
 
   /**
    * function to run when the user clicks on a label
@@ -98,6 +119,7 @@
       class:rsOutOfLimit={isOutOfLimit(min, limits)}
       style="{orientationStart}: 0%;"
       data-val={coerceFloat(min, precision)}
+      data-index={0}
       on:pointerdown={(e) => {
         labelDown(e);
       }}
@@ -116,9 +138,9 @@
   {/if}
 
   {#if (all && rest !== false) || rest}
-    {#each Array(pipCount + 1) as _, i}
-      {@const val = getValueFromIndex(i, min, max, pipStep, step, precision)}
-      {#if val !== min && val !== max}
+    {#each Array(pipCount) as _, i}
+      {@const val = getValueFromIndex(i, min, max, finalPipStep, step, precision)}
+      {#if val > min && val < max}
         <span
           class="rsPip"
           class:rsSelected={isSelected(val, values, precision)}
@@ -126,6 +148,7 @@
           class:rsOutOfLimit={isOutOfLimit(val, limits)}
           style="{orientationStart}: {valueAsPercent(val, min, max, precision)}%;"
           data-val={val}
+          data-index={i}
           on:pointerdown={(e) => {
             labelDown(e);
           }}
@@ -153,6 +176,7 @@
       class:rsOutOfLimit={isOutOfLimit(max, limits)}
       style="{orientationStart}: 100%;"
       data-val={coerceFloat(max, precision)}
+      data-index={pipCount}
       on:pointerdown={(e) => {
         labelDown(e);
       }}

commit dd7847f528cef2de50f75985ac9fab4f76fa6d6a
Author: simeydotme <simey.me@gmail.com>
Date:   Sat Mar 22 19:07:50 2025 +0800

    improve perf & design for the floats
    
    - use 3d transforms to force gpu
    - round the floats a bit more
    - make padding slightly more attractive
    - use cubic easing

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index e416bad..62e8678 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -1089,18 +1089,20 @@
     position: absolute;
     left: 50%;
     bottom: 1.75em;
-    transform: translate(-50%, -50%);
     font-size: 1em;
     text-align: center;
-    opacity: 0;
     pointer-events: none;
     white-space: nowrap;
-    transition: all 0.2s ease;
     font-size: 0.9em;
     line-height: 1;
     padding: 0.33em 0.5em 0.5em;
-    border-radius: 0.2em;
+    border-radius: 0.5em;
     z-index: 3;
+    opacity: 0;
+    translate: -50% -50% 0.01px;
+    scale: 1;
+    transform-origin: center;
+    transition: all 0.22s cubic-bezier(0.33, 1, 0.68, 1);
   }
 
   :global(.rangeSlider .rangeHandle.rsActive .rangeFloat),
@@ -1108,7 +1110,8 @@
   :global(.rangeSlider.rsHoverable .rangeBar:hover .rangeFloat),
   :global(.rangeSlider.rsFocus .rangeBar .rangeFloat) {
     opacity: 1;
-    transform: translate(-50%, 0%);
+    scale: 1;
+    translate: -50% 0% 0.01px;
   }
 
   :global(.rangeSlider .rangeBar .rangeFloat) {

commit 4c51064695db008aefc8b802dd6ce68cf310e334
Author: simeydotme <simey.me@gmail.com>
Date:   Sat Mar 22 05:29:08 2025 +0800

    fix max slider translation

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index a9c0317..e416bad 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -479,7 +479,7 @@
    **/
   function rangeEndPercent(values: number[]) {
     if (range === 'max') {
-      return 0;
+      return 100;
     } else if (range === 'min') {
       return values[0];
     } else {

commit 0ef2b0e2c599242f4a4282c90b4b4471f4b8f168
Author: simeydotme <simey.me@gmail.com>
Date:   Sat Mar 22 04:49:15 2025 +0800

    convert slider so that handles and range use transforms
    
    - should slightly improve performance
    - no more left/right calcs for handle/range
    - fix a bug with pushy/gaps where it couldn't ever reach 0/100 %

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 8a23deb..a9c0317 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -2,7 +2,7 @@
 
 <script lang="ts">
   import { type SpringOpts, type Spring, spring as springStore } from 'svelte/motion';
-  import { createEventDispatcher } from 'svelte';
+  import { createEventDispatcher, onMount } from 'svelte';
   import {
     coerceFloat,
     valueAsPercent,
@@ -10,7 +10,9 @@
     constrainAndAlignValue,
     pureText,
     normalisedClient,
-    elementIndex
+    elementIndex,
+    percentAsValue,
+    calculatePointerValues
   } from '$lib/utils.js';
   import type { Pip, Formatter, NormalisedClient, RangeFormatter } from '$lib/types.js';
 
@@ -80,6 +82,9 @@
   let activeHandle = -1;
   let startValues: (number | undefined)[] = [];
   let previousValues: (number | undefined)[] = [];
+  let sliderSize = 0;
+  let rangeSize = 0;
+  let rangeStart = 0;
 
   // copy the initial values in to a spring function which
   // will update every time the values array is modified
@@ -240,6 +245,38 @@
       ? 'left'
       : ('right' as 'left' | 'right' | 'top' | 'bottom');
 
+  /**
+   * observe slider element size changes using ResizeObserver
+   * to update dimensions and recalculate handle positions
+   **/
+  function updateSliderSize(slider: HTMLDivElement | undefined) {
+    return requestAnimationFrame(() => {
+      if (slider) {
+        const dims = slider.getBoundingClientRect();
+        sliderSize = vertical ? dims.height : dims.width;
+      }
+    });
+  }
+
+  let resizeObserver: ResizeObserver;
+  let rafId: number;
+
+  onMount(() => {
+    if (slider) {
+      resizeObserver = new ResizeObserver((entries) => {
+        if (rafId) {
+          cancelAnimationFrame(rafId);
+        }
+        rafId = updateSliderSize(entries[0].target as HTMLDivElement);
+      }) as ResizeObserver;
+      resizeObserver.observe(slider);
+    }
+    return () => {
+      if (rafId) cancelAnimationFrame(rafId);
+      resizeObserver?.disconnect?.();
+    };
+  });
+
   /**
    * check if an element is a handle on the slider
    * @param {object} el dom object reference we want to check
@@ -278,40 +315,25 @@
    **/
   function getClosestHandle(clientPos: NormalisedClient) {
     if (!slider) return 0;
-    // first make sure we have the latest dimensions
-    // of the slider, as it may have changed size
-    const dims = slider.getBoundingClientRect();
-    // calculate the interaction position, percent and value
-    let handlePos = 0;
-    let handlePercent = 0;
-    let handleVal = 0;
-    if (vertical) {
-      handlePos = clientPos.y - dims.top;
-      handlePercent = (handlePos / dims.height) * 100;
-      handlePercent = reversed ? handlePercent : 100 - handlePercent;
-    } else {
-      handlePos = clientPos.x - dims.left;
-      handlePercent = (handlePos / dims.width) * 100;
-      handlePercent = reversed ? 100 - handlePercent : handlePercent;
-    }
-    handleVal = ((max - min) / 100) * handlePercent + min;
 
-    let closest;
+    // get the location of the interaction on the slider as a value
+    const { pointerVal: clickedVal } = calculatePointerValues(slider, clientPos, vertical, reversed, min, max);
 
-    // if we have a range, and the handles are at the same
-    // position, we want a simple check if the interaction
-    // value is greater than return the second handle
+    let closest = 0;
     if (range === true && values[0] === values[1]) {
-      if (handleVal > values[1]) {
-        return 1;
+      // if we have a range, and the handles are at the same
+      // position, we want a simple check if the interaction
+      // value is greater than return the second handle
+      if (clickedVal > values[1]) {
+        closest = 1;
       } else {
-        return 0;
+        closest = 0;
       }
+    } else {
       // if there are multiple handles, and not a range, then
       // we sort the handles values, and return the first one closest
       // to the interaction value
-    } else {
-      closest = values.indexOf([...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]);
+      closest = values.indexOf([...values].sort((a, b) => Math.abs(clickedVal - a) - Math.abs(clickedVal - b))[0]);
     }
     return closest;
   }
@@ -325,43 +347,22 @@
    **/
   function handleInteract(clientPos: NormalisedClient) {
     if (!slider || !handleActivated) return;
-    // first make sure we have the latest dimensions
-    // of the slider, as it may have changed size
-    const dims = slider.getBoundingClientRect();
-    // calculate the interaction position, percent and value
-    let handlePos = 0;
-    let handlePercent = 0;
-    let handleVal = 0;
-    if (vertical) {
-      handlePos = clientPos.y - dims.top;
-      handlePercent = (handlePos / dims.height) * 100;
-      handlePercent = reversed ? handlePercent : 100 - handlePercent;
-    } else {
-      handlePos = clientPos.x - dims.left;
-      handlePercent = (handlePos / dims.width) * 100;
-      handlePercent = reversed ? 100 - handlePercent : handlePercent;
-    }
-    handleVal = ((max - min) / 100) * handlePercent + min;
+    // get the location of the interaction on the slider as a value
+    const { pointerVal: handleVal } = calculatePointerValues(slider, clientPos, vertical, reversed, min, max);
     // move handle to the value
     moveHandle(activeHandle, handleVal);
   }
 
-  function getRangedistancesOnInteractionStart(clientPos: NormalisedClient) {
+  /**
+   * save the distance between the handles and the interaction position
+   * when the user first starts dragging the range
+   * @param {object} clientPos the client {x,y} of the interaction
+   */
+  function getRangeDistancesOnInteractionStart(clientPos: NormalisedClient) {
     if (!slider || !draggy || !rangeActivated || range === 'min' || range === 'max') return;
-    const dims = slider.getBoundingClientRect();
-    let pointerPos = 0;
-    let pointerPercent = 0;
-    let pointerVal = 0;
-    if (vertical) {
-      pointerPos = clientPos.y - dims.top;
-      pointerPercent = (pointerPos / dims.height) * 100;
-      pointerPercent = reversed ? pointerPercent : 100 - pointerPercent;
-    } else {
-      pointerPos = clientPos.x - dims.left;
-      pointerPercent = (pointerPos / dims.width) * 100;
-      pointerPercent = reversed ? 100 - pointerPercent : pointerPercent;
-    }
-    pointerVal = ((max - min) / 100) * pointerPercent + min;
+    // get the location of the interaction on the slider as a value
+    const { pointerVal } = calculatePointerValues(slider, clientPos, vertical, reversed, min, max);
+    // store the distances for later use
     rangeDistancesFromPointer = [values[0] - pointerVal, values[1] - pointerVal];
   }
 
@@ -374,24 +375,11 @@
    */
   function rangeInteract(clientPos: NormalisedClient) {
     if (!slider || !draggy || !rangeActivated || range === 'min' || range === 'max') return;
-    // first make sure we have the latest dimensions
-    // of the slider, as it may have changed size
-    const dims = slider.getBoundingClientRect();
-    // calculate the interaction position, percent and value
-    let pointerPos = 0;
-    let pointerPercent = 0;
-    let pointerVal = 0;
-    if (vertical) {
-      pointerPos = clientPos.y - dims.top;
-      pointerPercent = (pointerPos / dims.height) * 100;
-      pointerPercent = reversed ? pointerPercent : 100 - pointerPercent;
-    } else {
-      pointerPos = clientPos.x - dims.left;
-      pointerPercent = (pointerPos / dims.width) * 100;
-      pointerPercent = reversed ? 100 - pointerPercent : pointerPercent;
-    }
-    pointerVal = ((max - min) / 100) * pointerPercent + min;
+    // get the location of the interaction on the slider as a value
+    const { pointerVal } = calculatePointerValues(slider, clientPos, vertical, reversed, min, max);
+    // if dragging the range, we dont want to 'activate' a handle
     activeHandle = -1;
+    // move the handles
     moveHandle(0, pointerVal + rangeDistancesFromPointer[0], false);
     moveHandle(1, pointerVal + rangeDistancesFromPointer[1], true);
   }
@@ -417,7 +405,7 @@
       // going past one-another unless "pushy" is true
       if (index === 0) {
         if (value > values[1] - rangeGapMin) {
-          if (pushy && value < (limits?.[1] ?? max) - rangeGapMin) {
+          if (pushy && value <= (limits?.[1] ?? max) - rangeGapMin) {
             values[1] = value + rangeGapMin;
           } else {
             value = values[1] - rangeGapMin;
@@ -430,13 +418,13 @@
           }
         }
       } else if (index === 1) {
-        if (value < coerceFloat(values[0] + rangeGapMin, precision)) {
-          if (pushy && value > (limits?.[0] ?? min) + rangeGapMin) {
+        if (value < values[0] + rangeGapMin) {
+          if (pushy && value >= (limits?.[0] ?? min) + rangeGapMin) {
             values[0] = value - rangeGapMin;
           } else {
             value = values[0] + rangeGapMin;
           }
-        } else if (value > coerceFloat(values[0] + rangeGapMax, precision)) {
+        } else if (value > values[0] + rangeGapMax) {
           if (pushy) {
             values[0] = value - rangeGapMax;
           } else {
@@ -474,9 +462,9 @@
   /**
    * helper to find the beginning range value for use with css style
    * @param {array} values the input values for the rangeSlider
-   * @return {number} the beginning of the range
+   * @return {number} the beginning of the range as a percentage of the total range
    **/
-  function rangeStart(values: number[]) {
+  function rangeStartPercent(values: number[]) {
     if (range === 'min') {
       return 0;
     } else {
@@ -487,15 +475,15 @@
   /**
    * helper to find the ending range value for use with css style
    * @param {array} values the input values for the rangeSlider
-   * @return {number} the end of the range
+   * @return {number} the end of the range as a percentage of the total range
    **/
-  function rangeEnd(values: number[]) {
+  function rangeEndPercent(values: number[]) {
     if (range === 'max') {
       return 0;
     } else if (range === 'min') {
-      return 100 - values[0];
+      return values[0];
     } else {
-      return 100 - values[1];
+      return values[1];
     }
   }
 
@@ -595,7 +583,7 @@
         activeHandle = -1;
         rangeActivated = true;
         rangePressed = true;
-        getRangedistancesOnInteractionStart(clientPos);
+        getRangeDistancesOnInteractionStart(clientPos);
       } else {
         handleActivated = true;
         handlePressed = true;
@@ -773,6 +761,7 @@
   class:rsFocus={focus}
   class:rsPips={pips}
   class:rsPipLabels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}
+  style:--slider-length={sliderSize}
   {style}
   on:mousedown={sliderInteractStart}
   on:mouseup={sliderInteractEnd}
@@ -780,8 +769,8 @@
   on:touchend|preventDefault={sliderInteractEnd}
 >
   {#each values as value, index}
-    {@const zindex = `z-index: ${activeHandle === index ? 3 : 2};`}
-    {@const handlePos = `${orientationStart}: ${$springPositions[index]}%;`}
+    {@const zindex = `${focus && activeHandle === index ? 3 : ''}`}
+    {@const translate = `calc((${sliderSize}px * ${$springPositions[index] / 100}))`}
     <span
       role="slider"
       class="rangeHandle"
@@ -791,7 +780,8 @@
       on:blur={sliderBlurHandle}
       on:focus={sliderFocusHandle}
       on:keydown={sliderKeydown}
-      style="{handlePos} {zindex}"
+      style:z-index={zindex}
+      style:--handle-pos={$springPositions[index]}
       aria-label={ariaLabels[index]}
       aria-valuemin={range === true && index === 1 ? values[0] : min}
       aria-valuemax={range === true && index === 0 ? values[1] : max}
@@ -824,8 +814,9 @@
     <span
       class="rangeBar"
       class:rsPress={rangePressed}
-      style="{orientationStart}: {rangeStart($springPositions)}%; 
-             {orientationEnd}: {rangeEnd($springPositions)}%;"
+      style:--range-start={rangeStartPercent($springPositions)}
+      style:--range-end={rangeEndPercent($springPositions)}
+      style:--range-size={rangeEndPercent($springPositions) - rangeStartPercent($springPositions)}
     >
       {#if rangeFloat}
         <span class="rangeFloat">
@@ -996,21 +987,25 @@
     top: 0.25em;
     bottom: auto;
     transform: translateY(-50%) translateX(-50%);
+    translate: calc(var(--slider-length) * (var(--handle-pos) / 100) * 1px) 0;
     z-index: 2;
   }
 
   :global(.rangeSlider.rsReversed .rangeHandle) {
-    transform: translateY(-50%) translateX(50%);
+    transform: translateY(-50%) translateX(-50%);
+    translate: calc((var(--slider-length) * 1px) - (var(--slider-length) * (var(--handle-pos) / 100) * 1px)) 0;
   }
 
   :global(.rangeSlider.rsVertical .rangeHandle) {
     left: 0.25em;
     top: auto;
-    transform: translateY(50%) translateX(-50%);
+    transform: translateY(-50%) translateX(-50%);
+    translate: 0 calc(var(--slider-length) * (1 - var(--handle-pos) / 100) * 1px);
   }
 
   :global(.rangeSlider.rsVertical.rsReversed .rangeHandle) {
     transform: translateY(-50%) translateX(-50%);
+    translate: 0 calc((var(--slider-length) * 1px) - (var(--slider-length) * (1 - var(--handle-pos) / 100) * 1px));
   }
 
   :global(.rangeSlider .rangeNub),
@@ -1160,6 +1155,23 @@
     height: auto;
   }
 
+  :global(.rangeSlider .rangeBar) {
+    translate: calc((var(--slider-length) * (var(--range-start) / 100) * 1px)) 0;
+    width: calc(var(--slider-length) * (var(--range-size) / 100 * 1px));
+  }
+  :global(.rangeSlider.rsReversed .rangeBar) {
+    translate: calc((var(--slider-length) * 1px) - (var(--slider-length) * (var(--range-end) / 100) * 1px)) 0;
+  }
+
+  :global(.rangeSlider.rsVertical .rangeBar) {
+    translate: 0 calc((var(--slider-length) * 1px) - (var(--slider-length) * (var(--range-end) / 100) * 1px));
+    height: calc(var(--slider-length) * (var(--range-size) / 100 * 1px));
+  }
+
+  :global(.rangeSlider.rsVertical.rsReversed .rangeBar) {
+    translate: 0 calc((var(--slider-length) * (var(--range-start) / 100) * 1px));
+  }
+
   :global(.rangeSlider.rsDrag .rangeBar::before) {
     content: '';
     inset: 0;

commit d268acc4121b209f5a605ab13afa392bde1a55d6
Author: simeydotme <simey.me@gmail.com>
Date:   Sat Mar 22 04:28:48 2025 +0800

    force pips to be gpu-transformed
    
    - improves css rendering a bit for hiDPI and when pips are off-grid

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index ebf4e9c..485891a 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -191,6 +191,7 @@
 
   :global(.rangePips) {
     position: absolute;
+    transform: translate3d(0, 0, 0.001px);
     height: 1em;
     left: 0;
     right: 0;
@@ -213,6 +214,7 @@
     top: 0.25em;
     width: 1px;
     white-space: nowrap;
+    transform: translate3d(0, 0, 0.001px);
   }
 
   :global(.rangePips.rsVertical .rsPip) {

commit 8c31507fa4fc393081efeaa2cf2ef1b0dfb270c5
Author: simeydotme <simey.me@gmail.com>
Date:   Thu Mar 20 21:29:03 2025 +0800

    add tests for rangeGapMin and Max
    
    - also update test files UI with tailwind/daisyui
    - update existing tests to use the new css classNames

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index e92dc93..8a23deb 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -893,9 +893,8 @@
    * RangeSlider
    */
 
-   @layer base {
+  @layer base {
     :global(.rangeSlider) {
-
       --slider-accent: #4a40d4;
       --slider-accent-100: #838de7;
       --slider-base: #99a2a2;
@@ -1023,7 +1022,9 @@
     border-radius: 10em;
     height: 100%;
     width: 100%;
-    transition: background 0.2s ease, box-shadow 0.2s ease;
+    transition:
+      background 0.2s ease,
+      box-shadow 0.2s ease;
   }
 
   :global(.rangeSlider .rangeHandle::before) {
@@ -1036,7 +1037,9 @@
     width: auto;
     box-shadow: 0 0 0 0px var(--handle-border);
     opacity: 0;
-    transition: opacity 0.2s ease, box-shadow 0.2s ease;
+    transition:
+      opacity 0.2s ease,
+      box-shadow 0.2s ease;
   }
 
   :global(.rangeSlider.rsHoverable:not(.rsDisabled) .rangeHandle:hover::before) {

commit 4b121f46e3cd0afccfa6e48db386c605d5b3e4ae
Author: simeydotme <simey.me@gmail.com>
Date:   Thu Mar 20 19:17:30 2025 +0800

    fix a bug with float coercion
    
    - the values being updated on move were not coercing to float precision

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index f60a68a..e92dc93 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -430,13 +430,13 @@
           }
         }
       } else if (index === 1) {
-        if (value < values[0] + rangeGapMin) {
+        if (value < coerceFloat(values[0] + rangeGapMin, precision)) {
           if (pushy && value > (limits?.[0] ?? min) + rangeGapMin) {
             values[0] = value - rangeGapMin;
           } else {
             value = values[0] + rangeGapMin;
           }
-        } else if (value > values[0] + rangeGapMax) {
+        } else if (value > coerceFloat(values[0] + rangeGapMax, precision)) {
           if (pushy) {
             values[0] = value - rangeGapMax;
           } else {
@@ -448,7 +448,7 @@
 
     // if the value has changed, update it
     if (values[index] !== value) {
-      constrainAndAlignValue((values[index] = value), min, max, step, precision, limits);
+      values[index] = constrainAndAlignValue(value, min, max, step, precision, limits);
     }
     if (fireEvent) {
       fireChangeEvent(values);
@@ -552,13 +552,13 @@
         case 'PageUp':
         case 'ArrowRight':
         case 'ArrowUp':
-          moveHandle(handle, values[handle] + coerceFloat(jump, precision));
+          moveHandle(handle, values[handle] + jump);
           prevent = true;
           break;
         case 'PageDown':
         case 'ArrowLeft':
         case 'ArrowDown':
-          moveHandle(handle, values[handle] - coerceFloat(jump, precision));
+          moveHandle(handle, values[handle] - jump);
           prevent = true;
           break;
         case 'Home':

commit a052118453fa14b5991984a7d4035d15f5d71da9
Author: simeydotme <simey.me@gmail.com>
Date:   Thu Mar 20 19:16:12 2025 +0800

    sanitise the rangeGaps on init
    
    - range gap cannot be less than 0
    - range gap min cannot be more than max

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 7614918..f60a68a 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -135,6 +135,11 @@
   const checkValuesAgainstRangeGaps = () => {
     // first, align the values to the step
     values = values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits));
+    // rangeGaps should be positive
+    if (rangeGapMin < 0) rangeGapMin = 0;
+    if (rangeGapMax < 0) rangeGapMax = Infinity;
+    // rangeGapMin must be less than rangeGapMax
+    if (rangeGapMin > rangeGapMax) rangeGapMin = rangeGapMax;
     // then, check the values against the range gaps
     if (rangeGapMax < Infinity) {
       const gapMax = constrainAndAlignValue(values[0] + rangeGapMax, min, max, step, precision, limits);

commit b8bc406b46adb8b7b236fabd45e463ab6ab99626
Author: simeydotme <simey.me@gmail.com>
Date:   Thu Mar 20 04:18:53 2025 +0800

    add `style` prop for passing css vars
    
    - also add subtle transitions for range bar
    - fix :before -> ::before
    - wrap css variables in @layer base {} to prevent conflict with tailwind

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index a5f82c6..7614918 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -61,6 +61,7 @@
   export let id: string | undefined = undefined;
   let classes = '';
   export { classes as class };
+  export let style: string | undefined = undefined;
   export let springValues: SpringOpts = { stiffness: 0.15, damping: 0.4 };
   export let spring = true;
 
@@ -767,6 +768,7 @@
   class:rsFocus={focus}
   class:rsPips={pips}
   class:rsPipLabels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}
+  {style}
   on:mousedown={sliderInteractStart}
   on:mouseup={sliderInteractEnd}
   on:touchstart|preventDefault={sliderInteractStart}
@@ -886,51 +888,41 @@
    * RangeSlider
    */
 
-  :global(.rangeSlider) {
-
-    --slider-accent: #4a40d4;
-    --slider-accent-100: #838de7;
-    --slider-base: #99a2a2;
-    --slider-base-100: #aebecf;
-    --slider-base-200: #b9c2c2;
-    --slider-bg: #d7dada;
-    --slider-fg: #3f3e4f;
-
-    --slider-dark-accent: #6070fc;
-    --slider-dark-accent-100: #7a7fab;
-    --slider-dark-base: #82809f;
-    --slider-dark-base-100: #595970;
-    --slider-dark-base-200: #454454;
-    --slider-dark-bg: #3f3e4f;
-    --slider-dark-fg: #d7dada;
-
-    --slider: var(--range-slider, var(--slider-bg));
-    --handle-inactive: var(--range-handle-inactive, var(--slider-base));
-    --handle: var(--range-handle, var(--slider-accent-100));
-    --handle-focus: var(--range-handle-focus, var(--slider-accent));
-    --handle-border: var(--range-handle-border, var(--handle));
-    --range-inactive: var(--range-range-inactive, var(--handle-inactive));
-    --range: var(--range-range, var(--handle-focus));
-    --range-limit: var(--range-range-limit, var(--slider-base-200));
-    --range-hover: var(--range-range-hover, var(--handle-border));
-    --range-press: var(--range-range-press, var(--handle-border));
-    --float-inactive: var(--range-float-inactive, var(--handle-inactive));
-    --float: var(--range-float, var(--handle-focus));
-    --float-text: var(--range-float-text, white);
-  }
-
-  :global(.rangeSlider.dark) {
-    --slider-accent: var(--slider-dark-accent);
-    --slider-accent-100: var(--slider-dark-accent-100);
-    --slider-base: var(--slider-dark-base);
-    --slider-base-100: var(--slider-dark-base-100);
-    --slider-base-200: var(--slider-dark-base-200);
-    --slider-bg: var(--slider-dark-bg);
-    --slider-fg: var(--slider-dark-fg);
-  }
-
-  @media (prefers-color-scheme: dark) {
+   @layer base {
     :global(.rangeSlider) {
+
+      --slider-accent: #4a40d4;
+      --slider-accent-100: #838de7;
+      --slider-base: #99a2a2;
+      --slider-base-100: #aebecf;
+      --slider-base-200: #b9c2c2;
+      --slider-bg: #d7dada;
+      --slider-fg: #3f3e4f;
+
+      --slider-dark-accent: #6070fc;
+      --slider-dark-accent-100: #7a7fab;
+      --slider-dark-base: #82809f;
+      --slider-dark-base-100: #595970;
+      --slider-dark-base-200: #454454;
+      --slider-dark-bg: #3f3e4f;
+      --slider-dark-fg: #d7dada;
+
+      --slider: var(--range-slider, var(--slider-bg));
+      --handle-inactive: var(--range-handle-inactive, var(--slider-base));
+      --handle: var(--range-handle, var(--slider-accent-100));
+      --handle-focus: var(--range-handle-focus, var(--slider-accent));
+      --handle-border: var(--range-handle-border, var(--handle));
+      --range-inactive: var(--range-range-inactive, var(--handle-inactive));
+      --range: var(--range-range, var(--handle-focus));
+      --range-limit: var(--range-range-limit, var(--slider-base-200));
+      --range-hover: var(--range-range-hover, var(--handle-border));
+      --range-press: var(--range-range-press, var(--handle-border));
+      --float-inactive: var(--range-float-inactive, var(--handle-inactive));
+      --float: var(--range-float, var(--handle-focus));
+      --float-text: var(--range-float-text, white);
+    }
+
+    :global(.rangeSlider.dark) {
       --slider-accent: var(--slider-dark-accent);
       --slider-accent-100: var(--slider-dark-accent-100);
       --slider-base: var(--slider-dark-base);
@@ -939,6 +931,18 @@
       --slider-bg: var(--slider-dark-bg);
       --slider-fg: var(--slider-dark-fg);
     }
+
+    @media (prefers-color-scheme: dark) {
+      :global(.rangeSlider) {
+        --slider-accent: var(--slider-dark-accent);
+        --slider-accent-100: var(--slider-dark-accent-100);
+        --slider-base: var(--slider-dark-base);
+        --slider-base-100: var(--slider-dark-base-100);
+        --slider-base-200: var(--slider-dark-base-200);
+        --slider-bg: var(--slider-dark-bg);
+        --slider-fg: var(--slider-dark-fg);
+      }
+    }
   }
 
   :global(.rangeSlider) {
@@ -1006,7 +1010,7 @@
   }
 
   :global(.rangeSlider .rangeNub),
-  :global(.rangeSlider .rangeHandle:before) {
+  :global(.rangeSlider .rangeHandle::before) {
     position: absolute;
     left: 0;
     top: 0;
@@ -1014,10 +1018,10 @@
     border-radius: 10em;
     height: 100%;
     width: 100%;
-    transition: box-shadow 0.2s ease;
+    transition: background 0.2s ease, box-shadow 0.2s ease;
   }
 
-  :global(.rangeSlider .rangeHandle:before) {
+  :global(.rangeSlider .rangeHandle::before) {
     content: '';
     left: 1px;
     top: 1px;
@@ -1027,15 +1031,16 @@
     width: auto;
     box-shadow: 0 0 0 0px var(--handle-border);
     opacity: 0;
+    transition: opacity 0.2s ease, box-shadow 0.2s ease;
   }
 
-  :global(.rangeSlider.rsHoverable:not(.rsDisabled) .rangeHandle:hover:before) {
+  :global(.rangeSlider.rsHoverable:not(.rsDisabled) .rangeHandle:hover::before) {
     box-shadow: 0 0 0 8px var(--handle-border);
     opacity: 0.2;
   }
 
-  :global(.rangeSlider.rsHoverable:not(.rsDisabled) .rangeHandle.rsPress:before),
-  :global(.rangeSlider.rsHoverable:not(.rsDisabled) .rangeHandle.rsPress:hover:before) {
+  :global(.rangeSlider.rsHoverable:not(.rsDisabled) .rangeHandle.rsPress::before),
+  :global(.rangeSlider.rsHoverable:not(.rsDisabled) .rangeHandle.rsPress:hover::before) {
     box-shadow: 0 0 0 12px var(--handle-border);
     opacity: 0.4;
   }
@@ -1155,6 +1160,7 @@
     height: auto;
     background-color: var(--range-hover);
     opacity: 0;
+    scale: 1 0.5;
     transition:
       opacity 0.2s ease,
       scale 0.2s ease;
@@ -1169,6 +1175,7 @@
 
   :global(.rangeSlider.rsHoverable:not(.rsDisabled).rsDrag .rangeBar:hover::before) {
     opacity: 0.2;
+    scale: 1 1;
   }
 
   :global(.rangeSlider.rsHoverable:not(.rsDisabled).rsDrag .rangeBar.rsPress::before) {

commit 1047235e64e210a395c0c3b4c75144cdfba4ae62
Author: simeydotme <simey.me@gmail.com>
Date:   Thu Mar 20 03:11:08 2025 +0800

    add a dark mode, remove legacy fallback colors, update colors
    
    - no need to supply fallback colors anymore as all browsers  can handle
    css vars
    - add a dark mode style
      - can be applied directly with `.dark` class, or using browser pref
    - update css variables and tweak colors slightly
      - now the customisation can be greatly simplified by changing the
    theme colors instead of individual elements
      - still maintains existing css variables if use overrides them

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index 47f77ab..ebf4e9c 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -177,15 +177,15 @@
    */
 
   :global(.rangePips) {
-    --pip: var(--range-pip, lightslategray);
+    --pip: var(--range-pip, var(--slider-base));
     --pip-text: var(--range-pip-text, var(--pip));
-    --pip-active: var(--range-pip-active, darkslategrey);
+    --pip-active: var(--range-pip-active, var(--slider-fg));
     --pip-active-text: var(--range-pip-active-text, var(--pip-active));
-    --pip-hover: var(--range-pip-hover, darkslategrey);
+    --pip-hover: var(--range-pip-hover, var(--slider-fg));
     --pip-hover-text: var(--range-pip-hover-text, var(--pip-hover));
     --pip-in-range: var(--range-pip-in-range, var(--pip-active));
     --pip-in-range-text: var(--range-pip-in-range-text, var(--pip-active-text));
-    --pip-out-of-limit: var(--range-pip-out-of-limit, #aebecf);
+    --pip-out-of-limit: var(--range-pip-out-of-limit, var(--slider-base-100));
     --pip-out-of-limit-text: var(--range-pip-out-of-limit-text, var(--pip-out-of-limit));
   }
 
@@ -248,37 +248,27 @@
   }
 
   :global(.rangePips .rsPip) {
-    color: lightslategray;
     color: var(--pip-text);
-    background-color: lightslategray;
     background-color: var(--pip);
   }
 
   :global(.rangePips .rsPip.rsSelected) {
-    color: darkslategrey;
     color: var(--pip-active-text);
-    background-color: darkslategrey;
     background-color: var(--pip-active);
   }
 
   :global(.rangePips.rsHoverable:not(.rsDisabled) .rsPip:not(.rsOutOfLimit):hover) {
-    color: darkslategrey;
     color: var(--pip-hover-text);
-    background-color: darkslategrey;
     background-color: var(--pip-hover);
   }
 
   :global(.rangePips .rsPip.rsInRange) {
-    color: darkslategrey;
     color: var(--pip-in-range-text);
-    background-color: darkslategrey;
     background-color: var(--pip-in-range);
   }
 
   :global(.rangePips .rsPip.rsOutOfLimit) {
-    color: #aebecf;
     color: var(--pip-out-of-limit-text);
-    background-color: #aebecf;
     background-color: var(--pip-out-of-limit);
   }
 
diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 8810c73..a5f82c6 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -596,7 +596,7 @@
         activeHandle = getClosestHandle(clientPos);
         // for touch devices we want the handle to instantly
         // move to the position touched for more responsive feeling
-        if (event.type === 'touchstart' && !target.matches('.pipVal')) {
+        if (event.type === 'touchstart' && !target.matches('.rsPipVal')) {
           handleInteract(clientPos);
         }
       }
@@ -666,7 +666,7 @@
           focus = true;
           // don't trigger interact if the target is a handle (no need) or
           // if the target is a label (we want to move to that value from rangePips)
-          if (!targetIsHandle(target) && !target.matches('.pipVal')) {
+          if (!targetIsHandle(target) && !target.matches('.rsPipVal')) {
             handleInteract(normalisedClient(event));
           }
         }
@@ -887,14 +887,31 @@
    */
 
   :global(.rangeSlider) {
-    --slider: var(--range-slider, #d7dada);
-    --handle-inactive: var(--range-handle-inactive, #99a2a2);
-    --handle: var(--range-handle, #838de7);
-    --handle-focus: var(--range-handle-focus, #4a40d4);
+
+    --slider-accent: #4a40d4;
+    --slider-accent-100: #838de7;
+    --slider-base: #99a2a2;
+    --slider-base-100: #aebecf;
+    --slider-base-200: #b9c2c2;
+    --slider-bg: #d7dada;
+    --slider-fg: #3f3e4f;
+
+    --slider-dark-accent: #6070fc;
+    --slider-dark-accent-100: #7a7fab;
+    --slider-dark-base: #82809f;
+    --slider-dark-base-100: #595970;
+    --slider-dark-base-200: #454454;
+    --slider-dark-bg: #3f3e4f;
+    --slider-dark-fg: #d7dada;
+
+    --slider: var(--range-slider, var(--slider-bg));
+    --handle-inactive: var(--range-handle-inactive, var(--slider-base));
+    --handle: var(--range-handle, var(--slider-accent-100));
+    --handle-focus: var(--range-handle-focus, var(--slider-accent));
     --handle-border: var(--range-handle-border, var(--handle));
     --range-inactive: var(--range-range-inactive, var(--handle-inactive));
     --range: var(--range-range, var(--handle-focus));
-    --range-limit: var(--range-range-limit, #b9c2c2);
+    --range-limit: var(--range-range-limit, var(--slider-base-200));
     --range-hover: var(--range-range-hover, var(--handle-border));
     --range-press: var(--range-range-press, var(--handle-border));
     --float-inactive: var(--range-float-inactive, var(--handle-inactive));
@@ -902,6 +919,28 @@
     --float-text: var(--range-float-text, white);
   }
 
+  :global(.rangeSlider.dark) {
+    --slider-accent: var(--slider-dark-accent);
+    --slider-accent-100: var(--slider-dark-accent-100);
+    --slider-base: var(--slider-dark-base);
+    --slider-base-100: var(--slider-dark-base-100);
+    --slider-base-200: var(--slider-dark-base-200);
+    --slider-bg: var(--slider-dark-bg);
+    --slider-fg: var(--slider-dark-fg);
+  }
+
+  @media (prefers-color-scheme: dark) {
+    :global(.rangeSlider) {
+      --slider-accent: var(--slider-dark-accent);
+      --slider-accent-100: var(--slider-dark-accent-100);
+      --slider-base: var(--slider-dark-base);
+      --slider-base-100: var(--slider-dark-base-100);
+      --slider-base-200: var(--slider-dark-base-200);
+      --slider-bg: var(--slider-dark-bg);
+      --slider-fg: var(--slider-dark-fg);
+    }
+  }
+
   :global(.rangeSlider) {
     position: relative;
     border-radius: 100px;
@@ -1050,7 +1089,8 @@
     white-space: nowrap;
     transition: all 0.2s ease;
     font-size: 0.9em;
-    padding: 0.2em 0.4em;
+    line-height: 1;
+    padding: 0.33em 0.5em 0.5em;
     border-radius: 0.2em;
     z-index: 3;
   }
@@ -1141,49 +1181,39 @@
   }
 
   :global(.rangeSlider) {
-    background-color: #d7dada;
     background-color: var(--slider);
   }
 
   :global(.rangeSlider .rangeBar) {
-    background-color: #99a2a2;
     background-color: var(--range-inactive);
   }
 
   :global(.rangeSlider.rsFocus .rangeBar) {
-    background-color: #838de7;
     background-color: var(--range);
   }
 
   :global(.rangeSlider .rangeLimit) {
-    background-color: #99a2a280;
     background-color: var(--range-limit);
   }
 
   :global(.rangeSlider .rangeNub) {
-    background-color: #99a2a2;
     background-color: var(--handle-inactive);
   }
 
   :global(.rangeSlider.rsFocus .rangeNub) {
-    background-color: #838de7;
     background-color: var(--handle);
   }
 
   :global(.rangeSlider .rangeHandle.rsActive .rangeNub) {
-    background-color: #4a40d4;
     background-color: var(--handle-focus);
   }
 
   :global(.rangeSlider .rangeFloat) {
-    color: white;
     color: var(--float-text);
-    background-color: #99a2a2;
     background-color: var(--float-inactive);
   }
 
   :global(.rangeSlider.rsFocus .rangeFloat) {
-    background-color: #4a40d4;
     background-color: var(--float);
   }
 
@@ -1192,7 +1222,6 @@
   }
 
   :global(.rangeSlider.rsDisabled .rangeNub) {
-    background-color: #d7dada;
-    background-color: var(--slider);
+    background-color: var(--handle-inactive);
   }
 </style>

commit 2343440fb1fb8d233345e7684fa9d4198fd19774
Author: simeydotme <simey.me@gmail.com>
Date:   Wed Mar 19 23:57:26 2025 +0800

    rename css classes to prevent library-conflicts
    
    ⚠  breaking change !
    - see docs/upgrading.md for details

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index 1be0c2f..47f77ab 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -82,13 +82,20 @@
   }
 </script>
 
-<div class="rangePips" class:disabled class:hoverable class:vertical class:reversed class:focus>
+<div
+  class="rangePips"
+  class:rsDisabled={disabled}
+  class:rsHoverable={hoverable}
+  class:rsVertical={vertical}
+  class:rsReversed={reversed}
+  class:rsFocus={focus}
+>
   {#if (all && first !== false) || first}
     <span
-      class="pip first"
-      class:selected={isSelected(min, values, precision)}
-      class:in-range={isInRange(min, values, range)}
-      class:out-of-limit={isOutOfLimit(min, limits)}
+      class="rsPip rsPip--first"
+      class:rsSelected={isSelected(min, values, precision)}
+      class:rsInRange={isInRange(min, values, range)}
+      class:rsOutOfLimit={isOutOfLimit(min, limits)}
       style="{orientationStart}: 0%;"
       data-val={coerceFloat(min, precision)}
       on:pointerdown={(e) => {
@@ -99,10 +106,10 @@
       }}
     >
       {#if all === 'label' || first === 'label'}
-        <span class="pipVal">
-          {#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}
+        <span class="rsPipVal">
+          {#if prefix}<span class="rsPipValPrefix">{prefix}</span>{/if}
           {@html formatter(coerceFloat(min, precision), 0, 0)}
-          {#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+          {#if suffix}<span class="rsPipValSuffix">{suffix}</span>{/if}
         </span>
       {/if}
     </span>
@@ -113,10 +120,10 @@
       {@const val = getValueFromIndex(i, min, max, pipStep, step, precision)}
       {#if val !== min && val !== max}
         <span
-          class="pip"
-          class:selected={isSelected(val, values, precision)}
-          class:in-range={isInRange(val, values, range)}
-          class:out-of-limit={isOutOfLimit(val, limits)}
+          class="rsPip"
+          class:rsSelected={isSelected(val, values, precision)}
+          class:rsInRange={isInRange(val, values, range)}
+          class:rsOutOfLimit={isOutOfLimit(val, limits)}
           style="{orientationStart}: {valueAsPercent(val, min, max, precision)}%;"
           data-val={val}
           on:pointerdown={(e) => {
@@ -127,10 +134,10 @@
           }}
         >
           {#if all === 'label' || rest === 'label'}
-            <span class="pipVal">
-              {#if true || prefix}<span class="pipVal-prefix">{prefix}</span>{/if}
+            <span class="rsPipVal">
+              {#if true || prefix}<span class="rsPipValPrefix">{prefix}</span>{/if}
               {@html formatter(val, i, valueAsPercent(val, min, max, precision))}
-              {#if true || suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+              {#if true || suffix}<span class="rsPipValSuffix">{suffix}</span>{/if}
             </span>
           {/if}
         </span>
@@ -140,10 +147,10 @@
 
   {#if (all && last !== false) || last}
     <span
-      class="pip last"
-      class:selected={isSelected(max, values, precision)}
-      class:in-range={isInRange(max, values, range)}
-      class:out-of-limit={isOutOfLimit(max, limits)}
+      class="rsPip rsPip--last"
+      class:rsSelected={isSelected(max, values, precision)}
+      class:rsInRange={isInRange(max, values, range)}
+      class:rsOutOfLimit={isOutOfLimit(max, limits)}
       style="{orientationStart}: 100%;"
       data-val={coerceFloat(max, precision)}
       on:pointerdown={(e) => {
@@ -154,10 +161,10 @@
       }}
     >
       {#if all === 'label' || last === 'label'}
-        <span class="pipVal">
-          {#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}
+        <span class="rsPipVal">
+          {#if prefix}<span class="rsPipValPrefix">{prefix}</span>{/if}
           {@html formatter(coerceFloat(max, precision), pipCount, 100)}
-          {#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+          {#if suffix}<span class="rsPipValSuffix">{suffix}</span>{/if}
         </span>
       {/if}
     </span>
@@ -191,7 +198,7 @@
     font-variant-numeric: tabular-nums;
   }
 
-  :global(.rangePips.vertical) {
+  :global(.rangePips.rsVertical) {
     height: auto;
     width: 1em;
     left: 100%;
@@ -200,7 +207,7 @@
     bottom: 0;
   }
 
-  :global(.rangePips .pip) {
+  :global(.rangePips .rsPip) {
     height: 0.4em;
     position: absolute;
     top: 0.25em;
@@ -208,7 +215,7 @@
     white-space: nowrap;
   }
 
-  :global(.rangePips.vertical .pip) {
+  :global(.rangePips.rsVertical .rsPip) {
     height: 1px;
     width: 0.4em;
     left: 0.25em;
@@ -216,89 +223,89 @@
     bottom: auto;
   }
 
-  :global(.rangePips .pipVal) {
+  :global(.rangePips .rsPipVal) {
     position: absolute;
     top: 0.4em;
     transform: translate(-50%, 25%);
     display: inline-flex;
   }
 
-  :global(.rangePips.vertical .pipVal) {
+  :global(.rangePips.rsVertical .rsPipVal) {
     position: absolute;
     top: 0;
     left: 0.4em;
     transform: translate(25%, -50%);
   }
 
-  :global(.rangePips .pip) {
+  :global(.rangePips .rsPip) {
     transition: all 0.15s ease;
   }
 
-  :global(.rangePips .pipVal) {
+  :global(.rangePips .rsPipVal) {
     transition:
       all 0.15s ease,
       font-weight 0s linear;
   }
 
-  :global(.rangePips .pip) {
+  :global(.rangePips .rsPip) {
     color: lightslategray;
     color: var(--pip-text);
     background-color: lightslategray;
     background-color: var(--pip);
   }
 
-  :global(.rangePips .pip.selected) {
+  :global(.rangePips .rsPip.rsSelected) {
     color: darkslategrey;
     color: var(--pip-active-text);
     background-color: darkslategrey;
     background-color: var(--pip-active);
   }
 
-  :global(.rangePips.hoverable:not(.disabled) .pip:not(.out-of-limit):hover) {
+  :global(.rangePips.rsHoverable:not(.rsDisabled) .rsPip:not(.rsOutOfLimit):hover) {
     color: darkslategrey;
     color: var(--pip-hover-text);
     background-color: darkslategrey;
     background-color: var(--pip-hover);
   }
 
-  :global(.rangePips .pip.in-range) {
+  :global(.rangePips .rsPip.rsInRange) {
     color: darkslategrey;
     color: var(--pip-in-range-text);
     background-color: darkslategrey;
     background-color: var(--pip-in-range);
   }
 
-  :global(.rangePips .pip.out-of-limit) {
+  :global(.rangePips .rsPip.rsOutOfLimit) {
     color: #aebecf;
     color: var(--pip-out-of-limit-text);
     background-color: #aebecf;
     background-color: var(--pip-out-of-limit);
   }
 
-  :global(.rangePips .pip.selected) {
+  :global(.rangePips .rsPip.rsSelected) {
     height: 0.75em;
   }
 
-  :global(.rangePips.vertical .pip.selected) {
+  :global(.rangePips.rsVertical .rsPip.rsSelected) {
     height: 1px;
     width: 0.75em;
   }
 
-  :global(.rangePips .pip.selected .pipVal) {
+  :global(.rangePips .rsPip.rsSelected .rsPipVal) {
     font-weight: bold;
     top: 0.75em;
   }
 
-  :global(.rangePips.vertical .pip.selected .pipVal) {
+  :global(.rangePips.rsVertical .rsPip.rsSelected .rsPipVal) {
     top: 0;
     left: 0.75em;
   }
 
-  :global(.rangePips.hoverable:not(.disabled) .pip:not(.selected):not(.out-of-limit):hover) {
+  :global(.rangePips.rsHoverable:not(.rsDisabled) .rsPip:not(.rsSelected):not(.rsOutOfLimit):hover) {
     transition: none;
   }
 
-  :global(.rangePips.hoverable:not(.disabled) .pip:not(.selected):not(.out-of-limit):hover .pipVal) {
+  :global(.rangePips.rsHoverable:not(.rsDisabled) .rsPip:not(.rsSelected):not(.rsOutOfLimit):hover .rsPipVal) {
     transition: none;
     font-weight: bold;
   }
diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 21d083c..8810c73 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -756,16 +756,17 @@
   bind:this={slider}
   role="none"
   class="rangeSlider {classes}"
-  class:range={hasRange}
-  class:min={range === 'min'}
-  class:max={range === 'max'}
-  class:disabled
-  class:hoverable
-  class:vertical
-  class:reversed
-  class:focus
-  class:pips
-  class:pip-labels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}
+  class:rsRange={hasRange}
+  class:rsDrag={hasRange && draggy}
+  class:rsMin={hasRange && range === 'min'}
+  class:rsMax={hasRange && range === 'max'}
+  class:rsDisabled={disabled}
+  class:rsHoverable={hoverable}
+  class:rsVertical={vertical}
+  class:rsReversed={reversed}
+  class:rsFocus={focus}
+  class:rsPips={pips}
+  class:rsPipLabels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}
   on:mousedown={sliderInteractStart}
   on:mouseup={sliderInteractEnd}
   on:touchstart|preventDefault={sliderInteractStart}
@@ -777,8 +778,8 @@
     <span
       role="slider"
       class="rangeHandle"
-      class:active={focus && activeHandle === index}
-      class:press={handlePressed && activeHandle === index}
+      class:rsActive={focus && activeHandle === index}
+      class:rsPress={handlePressed && activeHandle === index}
       data-handle={index}
       on:blur={sliderBlurHandle}
       on:focus={sliderFocusHandle}
@@ -798,8 +799,8 @@
         {@const percent = valueAsPercent(value, min, max, precision)}
         {@const formattedValue = handleFormatter(value, index, percent)}
         <span class="rangeFloat">
-          {#if prefix}<span class="rangeFloat-prefix">{prefix}</span>{/if}{@html formattedValue}{#if suffix}<span
-              class="rangeFloat-suffix">{suffix}</span
+          {#if prefix}<span class="rangeFloatPrefix">{prefix}</span>{/if}{@html formattedValue}{#if suffix}<span
+              class="rangeFloatSuffix">{suffix}</span
             >{/if}
         </span>
       {/if}
@@ -815,9 +816,7 @@
   {#if hasRange}
     <span
       class="rangeBar"
-      class:rangeDrag={draggy}
-      class:press={rangePressed}
-      class:range
+      class:rsPress={rangePressed}
       style="{orientationStart}: {rangeStart($springPositions)}%; 
              {orientationEnd}: {rangeEnd($springPositions)}%;"
     >
@@ -832,12 +831,12 @@
             )}
           {:else}
             {@const [first, second] = reversed ? [values[1], values[0]] : [values[0], values[1]]}
-            {#if prefix}<span class="rangeFloat-prefix">{prefix}</span>{/if}{@html first}{#if suffix}<span
-                class="rangeFloat-suffix">{suffix}</span
+            {#if prefix}<span class="rangeFloatPrefix">{prefix}</span>{/if}{@html first}{#if suffix}<span
+                class="rangeFloatSuffix">{suffix}</span
               >{/if}
             {' '}-{' '}
-            {#if prefix}<span class="rangeFloat-prefix">{prefix}</span>{/if}{@html second}{#if suffix}<span
-                class="rangeFloat-suffix">{suffix}</span
+            {#if prefix}<span class="rangeFloatPrefix">{prefix}</span>{/if}{@html second}{#if suffix}<span
+                class="rangeFloatSuffix">{suffix}</span
               >{/if}
           {/if}
         </span>
@@ -910,33 +909,34 @@
     margin: 1em;
     transition: opacity 0.2s ease;
     user-select: none;
+    overflow: visible;
   }
 
   :global(.rangeSlider *) {
     user-select: none;
   }
 
-  :global(.rangeSlider.pips) {
+  :global(.rangeSlider.rsPips) {
     margin-bottom: 1.8em;
   }
 
-  :global(.rangeSlider.pip-labels) {
+  :global(.rangeSlider.rsPipLabels) {
     margin-bottom: 2.8em;
   }
 
-  :global(.rangeSlider.vertical) {
+  :global(.rangeSlider.rsVertical) {
     display: inline-block;
     border-radius: 100px;
     width: 0.5em;
     min-height: 200px;
   }
 
-  :global(.rangeSlider.vertical.pips) {
+  :global(.rangeSlider.rsVertical.rsPips) {
     margin-right: 1.8em;
     margin-bottom: 1em;
   }
 
-  :global(.rangeSlider.vertical.pip-labels) {
+  :global(.rangeSlider.rsVertical.rsPipLabels) {
     margin-right: 2.8em;
     margin-bottom: 1em;
   }
@@ -952,17 +952,17 @@
     z-index: 2;
   }
 
-  :global(.rangeSlider.reversed .rangeHandle) {
+  :global(.rangeSlider.rsReversed .rangeHandle) {
     transform: translateY(-50%) translateX(50%);
   }
 
-  :global(.rangeSlider.vertical .rangeHandle) {
+  :global(.rangeSlider.rsVertical .rangeHandle) {
     left: 0.25em;
     top: auto;
     transform: translateY(50%) translateX(-50%);
   }
 
-  :global(.rangeSlider.vertical.reversed .rangeHandle) {
+  :global(.rangeSlider.rsVertical.rsReversed .rangeHandle) {
     transform: translateY(-50%) translateX(-50%);
   }
 
@@ -990,50 +990,50 @@
     opacity: 0;
   }
 
-  :global(.rangeSlider.hoverable:not(.disabled) .rangeHandle:hover:before) {
+  :global(.rangeSlider.rsHoverable:not(.rsDisabled) .rangeHandle:hover:before) {
     box-shadow: 0 0 0 8px var(--handle-border);
     opacity: 0.2;
   }
 
-  :global(.rangeSlider.hoverable:not(.disabled) .rangeHandle.press:before),
-  :global(.rangeSlider.hoverable:not(.disabled) .rangeHandle.press:hover:before) {
+  :global(.rangeSlider.rsHoverable:not(.rsDisabled) .rangeHandle.rsPress:before),
+  :global(.rangeSlider.rsHoverable:not(.rsDisabled) .rangeHandle.rsPress:hover:before) {
     box-shadow: 0 0 0 12px var(--handle-border);
     opacity: 0.4;
   }
 
-  :global(.rangeSlider.range:not(.min):not(.max) .rangeNub) {
+  :global(.rangeSlider.rsRange:not(.rsMin):not(.rsMax) .rangeNub) {
     border-radius: 10em 10em 10em 1.6em;
   }
 
-  :global(.rangeSlider.range .rangeHandle:nth-of-type(1) .rangeNub) {
+  :global(.rangeSlider.rsRange .rangeHandle:nth-of-type(1) .rangeNub) {
     transform: rotate(-135deg);
   }
 
-  :global(.rangeSlider.range .rangeHandle:nth-of-type(2) .rangeNub) {
+  :global(.rangeSlider.rsRange .rangeHandle:nth-of-type(2) .rangeNub) {
     transform: rotate(45deg);
   }
 
-  :global(.rangeSlider.range.reversed .rangeHandle:nth-of-type(1) .rangeNub) {
+  :global(.rangeSlider.rsRange.rsReversed .rangeHandle:nth-of-type(1) .rangeNub) {
     transform: rotate(45deg);
   }
 
-  :global(.rangeSlider.range.reversed .rangeHandle:nth-of-type(2) .rangeNub) {
+  :global(.rangeSlider.rsRange.rsReversed .rangeHandle:nth-of-type(2) .rangeNub) {
     transform: rotate(-135deg);
   }
 
-  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(1) .rangeNub) {
+  :global(.rangeSlider.rsRange.rsVertical .rangeHandle:nth-of-type(1) .rangeNub) {
     transform: rotate(135deg);
   }
 
-  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(2) .rangeNub) {
+  :global(.rangeSlider.rsRange.rsVertical .rangeHandle:nth-of-type(2) .rangeNub) {
     transform: rotate(-45deg);
   }
 
-  :global(.rangeSlider.range.vertical.reversed .rangeHandle:nth-of-type(1) .rangeNub) {
+  :global(.rangeSlider.rsRange.rsVertical.rsReversed .rangeHandle:nth-of-type(1) .rangeNub) {
     transform: rotate(-45deg);
   }
 
-  :global(.rangeSlider.range.vertical.reversed .rangeHandle:nth-of-type(2) .rangeNub) {
+  :global(.rangeSlider.rsRange.rsVertical.rsReversed .rangeHandle:nth-of-type(2) .rangeNub) {
     transform: rotate(135deg);
   }
 
@@ -1055,10 +1055,10 @@
     z-index: 3;
   }
 
-  :global(.rangeSlider .rangeHandle.active .rangeFloat),
-  :global(.rangeSlider.hoverable .rangeHandle:hover .rangeFloat),
-  :global(.rangeSlider.hoverable .rangeBar:hover .rangeFloat),
-  :global(.rangeSlider.focus .rangeBar .rangeFloat) {
+  :global(.rangeSlider .rangeHandle.rsActive .rangeFloat),
+  :global(.rangeSlider.rsHoverable .rangeHandle:hover .rangeFloat),
+  :global(.rangeSlider.rsHoverable .rangeBar:hover .rangeFloat),
+  :global(.rangeSlider.rsFocus .rangeBar .rangeFloat) {
     opacity: 1;
     transform: translate(-50%, 0%);
   }
@@ -1068,7 +1068,7 @@
     z-index: 2;
   }
 
-  :global(.rangeSlider.vertical .rangeFloat) {
+  :global(.rangeSlider.rsVertical .rangeFloat) {
     top: 50%;
     bottom: auto;
     left: auto;
@@ -1076,20 +1076,20 @@
     transform: translate(-50%, -50%);
   }
 
-  :global(.rangeSlider.vertical .rangeHandle.active .rangeFloat),
-  :global(.rangeSlider.vertical.hoverable .rangeHandle:hover .rangeFloat),
-  :global(.rangeSlider.vertical.hoverable .rangeBar:hover .rangeFloat),
-  :global(.rangeSlider.vertical.focus .rangeBar .rangeFloat) {
+  :global(.rangeSlider.rsVertical .rangeHandle.rsActive .rangeFloat),
+  :global(.rangeSlider.rsVertical.rsHoverable .rangeHandle:hover .rangeFloat),
+  :global(.rangeSlider.rsVertical.rsHoverable .rangeBar:hover .rangeFloat),
+  :global(.rangeSlider.rsVertical.rsFocus .rangeBar .rangeFloat) {
     transform: translate(0%, -50%);
   }
 
-  :global(.rangeSlider.vertical .rangeBar .rangeFloat) {
+  :global(.rangeSlider.rsVertical .rangeBar .rangeFloat) {
     right: 0.875em;
   }
 
   :global(.rangeSlider .rangeBar),
-  :global(.rangeSlider .rangeBar.rangeDrag::before),
-  :global(.rangeSlider .rangeLimit) {
+  :global(.rangeSlider .rangeLimit),
+  :global(.rangeSlider.rsDrag .rangeBar::before) {
     position: absolute;
     display: block;
     transition: background 0.2s ease;
@@ -1100,14 +1100,14 @@
     z-index: 1;
   }
 
-  :global(.rangeSlider.vertical .rangeBar),
-  :global(.rangeSlider.vertical .rangeBar.rangeDrag::before),
-  :global(.rangeSlider.vertical .rangeLimit) {
+  :global(.rangeSlider.rsVertical .rangeBar),
+  :global(.rangeSlider.rsVertical .rangeLimit),
+  :global(.rangeSlider.rsVertical.rsDrag .rangeBar::before) {
     width: 0.5em;
     height: auto;
   }
 
-  :global(.rangeSlider .rangeBar.rangeDrag::before) {
+  :global(.rangeSlider.rsDrag .rangeBar::before) {
     content: '';
     inset: 0;
     top: -0.5em;
@@ -1120,23 +1120,23 @@
       scale 0.2s ease;
   }
 
-  :global(.rangeSlider.vertical .rangeBar.rangeDrag::before) {
+  :global(.rangeSlider.rsVertical.rsDrag .rangeBar::before) {
     inset: 0;
     left: -0.5em;
     right: -0.5em;
     width: auto;
   }
 
-  :global(.rangeSlider.hoverable:not(.disabled) .rangeDrag:hover::before) {
+  :global(.rangeSlider.rsHoverable:not(.rsDisabled).rsDrag .rangeBar:hover::before) {
     opacity: 0.2;
   }
 
-  :global(.rangeSlider.hoverable:not(.disabled) .rangeDrag.press::before) {
+  :global(.rangeSlider.rsHoverable:not(.rsDisabled).rsDrag .rangeBar.rsPress::before) {
     opacity: 0.4;
     scale: 1 1.25;
   }
 
-  :global(.rangeSlider.vertical.hoverable:not(.disabled) .rangeDrag.press::before) {
+  :global(.rangeSlider.rsVertical.rsHoverable:not(.rsDisabled).rsDrag .rangeBar.rsPress::before) {
     scale: 1.25 1;
   }
 
@@ -1150,7 +1150,7 @@
     background-color: var(--range-inactive);
   }
 
-  :global(.rangeSlider.focus .rangeBar) {
+  :global(.rangeSlider.rsFocus .rangeBar) {
     background-color: #838de7;
     background-color: var(--range);
   }
@@ -1165,12 +1165,12 @@
     background-color: var(--handle-inactive);
   }
 
-  :global(.rangeSlider.focus .rangeNub) {
+  :global(.rangeSlider.rsFocus .rangeNub) {
     background-color: #838de7;
     background-color: var(--handle);
   }
 
-  :global(.rangeSlider .rangeHandle.active .rangeNub) {
+  :global(.rangeSlider .rangeHandle.rsActive .rangeNub) {
     background-color: #4a40d4;
     background-color: var(--handle-focus);
   }
@@ -1182,16 +1182,16 @@
     background-color: var(--float-inactive);
   }
 
-  :global(.rangeSlider.focus .rangeFloat) {
+  :global(.rangeSlider.rsFocus .rangeFloat) {
     background-color: #4a40d4;
     background-color: var(--float);
   }
 
-  :global(.rangeSlider.disabled) {
+  :global(.rangeSlider.rsDisabled) {
     opacity: 0.5;
   }
 
-  :global(.rangeSlider.disabled .rangeNub) {
+  :global(.rangeSlider.rsDisabled .rangeNub) {
     background-color: #d7dada;
     background-color: var(--slider);
   }

commit e60e88ed45ae3cf3b17c80c844ee436d72fe056e
Author: simeydotme <simey.me@gmail.com>
Date:   Tue Mar 18 03:12:15 2025 +0800

    add a bunch of tests for range/handle formatting

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 0ad622b..21d083c 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -149,11 +149,23 @@
     }
   };
 
+  const checkFormatters = () => {
+    if (formatter === null || formatter === undefined) {
+      console.error('formatter must be a function');
+      formatter = (v, i, p) => v;
+    }
+    if (handleFormatter === null || handleFormatter === undefined) {
+      console.error('handleFormatter must be a function');
+      handleFormatter = formatter;
+    }
+  };
+
   // fixup the value/values at render
   checkValueIsNumber();
   checkValuesIsArray();
   checkValuesAgainstRangeGaps();
   checkMinMax();
+  checkFormatters();
 
   // keep value and values in sync with each other
   $: value, updateValues();
@@ -161,6 +173,8 @@
   $: ariaLabels, checkAriaLabels();
   $: min, checkMinMax();
   $: max, checkMinMax();
+  $: formatter, checkFormatters();
+  $: handleFormatter, checkFormatters();
   $: hasRange =
     (range === true && values.length === 2) || ((range === 'min' || range === 'max') && values.length === 1);
 
@@ -1027,8 +1041,8 @@
     display: block;
     position: absolute;
     left: 50%;
-    top: -0.5em;
-    transform: translate(-50%, -100%);
+    bottom: 1.75em;
+    transform: translate(-50%, -50%);
     font-size: 1em;
     text-align: center;
     opacity: 0;
@@ -1043,11 +1057,34 @@
 
   :global(.rangeSlider .rangeHandle.active .rangeFloat),
   :global(.rangeSlider.hoverable .rangeHandle:hover .rangeFloat),
-  :global(.rangeSlider.hoverable:hover .rangeBar .rangeFloat),
+  :global(.rangeSlider.hoverable .rangeBar:hover .rangeFloat),
   :global(.rangeSlider.focus .rangeBar .rangeFloat) {
     opacity: 1;
-    top: -0.2em;
-    transform: translate(-50%, -100%);
+    transform: translate(-50%, 0%);
+  }
+
+  :global(.rangeSlider .rangeBar .rangeFloat) {
+    bottom: 0.875em;
+    z-index: 2;
+  }
+
+  :global(.rangeSlider.vertical .rangeFloat) {
+    top: 50%;
+    bottom: auto;
+    left: auto;
+    right: 1.75em;
+    transform: translate(-50%, -50%);
+  }
+
+  :global(.rangeSlider.vertical .rangeHandle.active .rangeFloat),
+  :global(.rangeSlider.vertical.hoverable .rangeHandle:hover .rangeFloat),
+  :global(.rangeSlider.vertical.hoverable .rangeBar:hover .rangeFloat),
+  :global(.rangeSlider.vertical.focus .rangeBar .rangeFloat) {
+    transform: translate(0%, -50%);
+  }
+
+  :global(.rangeSlider.vertical .rangeBar .rangeFloat) {
+    right: 0.875em;
   }
 
   :global(.rangeSlider .rangeBar),
@@ -1083,6 +1120,13 @@
       scale 0.2s ease;
   }
 
+  :global(.rangeSlider.vertical .rangeBar.rangeDrag::before) {
+    inset: 0;
+    left: -0.5em;
+    right: -0.5em;
+    width: auto;
+  }
+
   :global(.rangeSlider.hoverable:not(.disabled) .rangeDrag:hover::before) {
     opacity: 0.2;
   }
@@ -1092,6 +1136,10 @@
     scale: 1 1.25;
   }
 
+  :global(.rangeSlider.vertical.hoverable:not(.disabled) .rangeDrag.press::before) {
+    scale: 1.25 1;
+  }
+
   :global(.rangeSlider) {
     background-color: #d7dada;
     background-color: var(--slider);

commit 08ba1c921e7a4a59421affd45998b333bc46b409
Author: simeydotme <simey.me@gmail.com>
Date:   Mon Mar 17 10:49:46 2025 +0800

    rename vars

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index e34e634..0ad622b 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -74,7 +74,7 @@
   let handlePressed = false;
   let rangeActivated = false;
   let rangePressed = false;
-  let activeRangeGaps = [1, 1];
+  let rangeDistancesFromPointer = [1, 1];
   let keyboardActive = false;
   let activeHandle = -1;
   let startValues: (number | undefined)[] = [];
@@ -326,7 +326,7 @@
     moveHandle(activeHandle, handleVal);
   }
 
-  function getRangeGapsOnInteractionStart(clientPos: NormalisedClient) {
+  function getRangedistancesOnInteractionStart(clientPos: NormalisedClient) {
     if (!slider || !draggy || !rangeActivated || range === 'min' || range === 'max') return;
     const dims = slider.getBoundingClientRect();
     let pointerPos = 0;
@@ -342,7 +342,7 @@
       pointerPercent = reversed ? 100 - pointerPercent : pointerPercent;
     }
     pointerVal = ((max - min) / 100) * pointerPercent + min;
-    activeRangeGaps = [values[0] - pointerVal, values[1] - pointerVal];
+    rangeDistancesFromPointer = [values[0] - pointerVal, values[1] - pointerVal];
   }
 
   /**
@@ -372,8 +372,8 @@
     }
     pointerVal = ((max - min) / 100) * pointerPercent + min;
     activeHandle = -1;
-    moveHandle(0, pointerVal + activeRangeGaps[0], false);
-    moveHandle(1, pointerVal + activeRangeGaps[1], true);
+    moveHandle(0, pointerVal + rangeDistancesFromPointer[0], false);
+    moveHandle(1, pointerVal + rangeDistancesFromPointer[1], true);
   }
 
   /**
@@ -575,7 +575,7 @@
         activeHandle = -1;
         rangeActivated = true;
         rangePressed = true;
-        getRangeGapsOnInteractionStart(clientPos);
+        getRangedistancesOnInteractionStart(clientPos);
       } else {
         handleActivated = true;
         handlePressed = true;

commit cbc545c64de6caca63a7e6077cbbadb4605aa7cf
Author: simeydotme <simey.me@gmail.com>
Date:   Sat Mar 15 23:10:48 2025 +0800

    set slider widths to 1000px, test absolute css instead of style

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index 61fc440..1be0c2f 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -298,9 +298,7 @@
     transition: none;
   }
 
-  :global(
-      .rangePips.hoverable:not(.disabled) .pip:not(.selected):not(.out-of-limit):hover .pipVal
-    ) {
+  :global(.rangePips.hoverable:not(.disabled) .pip:not(.selected):not(.out-of-limit):hover .pipVal) {
     transition: none;
     font-weight: bold;
   }
diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 70be975..e34e634 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -136,27 +136,13 @@
     values = values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits));
     // then, check the values against the range gaps
     if (rangeGapMax < Infinity) {
-      const gapMax = constrainAndAlignValue(
-        values[0] + rangeGapMax,
-        min,
-        max,
-        step,
-        precision,
-        limits
-      );
+      const gapMax = constrainAndAlignValue(values[0] + rangeGapMax, min, max, step, precision, limits);
       if (values[1] > gapMax) {
         values[1] = gapMax;
       }
     }
     if (rangeGapMin > 0) {
-      const gapMin = constrainAndAlignValue(
-        values[0] + rangeGapMin,
-        min,
-        max,
-        step,
-        precision,
-        limits
-      );
+      const gapMin = constrainAndAlignValue(values[0] + rangeGapMin, min, max, step, precision, limits);
       if (values[1] < gapMin) {
         values[1] = gapMin;
       }
@@ -176,8 +162,7 @@
   $: min, checkMinMax();
   $: max, checkMinMax();
   $: hasRange =
-    (range === true && values.length === 2) ||
-    ((range === 'min' || range === 'max') && values.length === 1);
+    (range === true && values.length === 2) || ((range === 'min' || range === 'max') && values.length === 1);
 
   $: {
     // trim the range so it remains as a min/max (only 2 handles)
@@ -187,9 +172,7 @@
     );
     if (
       !(values.length === trimmedAlignedValues.length) ||
-      !values.every(
-        (element, index) => coerceFloat(element, precision) === trimmedAlignedValues[index]
-      )
+      !values.every((element, index) => coerceFloat(element, precision) === trimmedAlignedValues[index])
     ) {
       values = trimmedAlignedValues;
     }
@@ -308,9 +291,7 @@
       // we sort the handles values, and return the first one closest
       // to the interaction value
     } else {
-      closest = values.indexOf(
-        [...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]
-      );
+      closest = values.indexOf([...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]);
     }
     return closest;
   }
@@ -803,8 +784,8 @@
         {@const percent = valueAsPercent(value, min, max, precision)}
         {@const formattedValue = handleFormatter(value, index, percent)}
         <span class="rangeFloat">
-          {#if prefix}<span class="rangeFloat-prefix">{prefix}</span
-            >{/if}{@html formattedValue}{#if suffix}<span class="rangeFloat-suffix">{suffix}</span
+          {#if prefix}<span class="rangeFloat-prefix">{prefix}</span>{/if}{@html formattedValue}{#if suffix}<span
+              class="rangeFloat-suffix">{suffix}</span
             >{/if}
         </span>
       {/if}
@@ -837,11 +818,13 @@
             )}
           {:else}
             {@const [first, second] = reversed ? [values[1], values[0]] : [values[0], values[1]]}
-            {#if prefix}<span class="rangeFloat-prefix">{prefix}</span
-              >{/if}{@html first}{#if suffix}<span class="rangeFloat-suffix">{suffix}</span>{/if}
+            {#if prefix}<span class="rangeFloat-prefix">{prefix}</span>{/if}{@html first}{#if suffix}<span
+                class="rangeFloat-suffix">{suffix}</span
+              >{/if}
             {' '}-{' '}
-            {#if prefix}<span class="rangeFloat-prefix">{prefix}</span
-              >{/if}{@html second}{#if suffix}<span class="rangeFloat-suffix">{suffix}</span>{/if}
+            {#if prefix}<span class="rangeFloat-prefix">{prefix}</span>{/if}{@html second}{#if suffix}<span
+                class="rangeFloat-suffix">{suffix}</span
+              >{/if}
           {/if}
         </span>
       {/if}

commit 1d83ae6d6180efa668a93712e6c8f00b295fa08d
Author: simeydotme <simey.me@gmail.com>
Date:   Fri Mar 14 23:37:29 2025 +0800

    allow spring to be disabled, add 'class' prop
    
    - add a new prop; `spring` defaults to `true
            - set `false` will prevent animations on the slider handles
    - add a new prop; `class` defaults to `''`
            - allows adding css classes to the slider base element
            - similar to `id` prop

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 52a1597..70be975 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -1,7 +1,7 @@
 <svelte:options immutable={false} />
 
 <script lang="ts">
-  import { type SpringOpts, type Spring, spring } from 'svelte/motion';
+  import { type SpringOpts, type Spring, spring as springStore } from 'svelte/motion';
   import { createEventDispatcher } from 'svelte';
   import {
     coerceFloat,
@@ -50,7 +50,6 @@
   export let rest: Pip = undefined;
 
   // formatting props
-  export let id: string | undefined = undefined;
   export let prefix: string = '';
   export let suffix: string = '';
   export let formatter: Formatter = (v, i, p) => v;
@@ -59,7 +58,11 @@
   export let ariaLabels: string[] = [];
 
   // stylistic props
+  export let id: string | undefined = undefined;
+  let classes = '';
+  export { classes as class };
   export let springValues: SpringOpts = { stiffness: 0.15, damping: 0.4 };
+  export let spring = true;
 
   // prepare dispatched events
   const dispatch = createEventDispatcher();
@@ -197,14 +200,19 @@
     if (valueLength !== values.length) {
       // set the initial spring values when the slider initialises,
       // or when values array length has changed
-      springPositions = spring(
+      springPositions = springStore(
         values.map((v) => valueAsPercent(v, min, max)),
         springValues
       );
     } else {
       // update the value of the spring function for animated handles
       // whenever the values has updated
-      springPositions.set(values.map((v) => valueAsPercent(v, min, max)));
+      requestAnimationFrame(() => {
+        springPositions.set(
+          values.map((v) => valueAsPercent(v, min, max)),
+          { hard: !spring }
+        );
+      });
     }
     // set the valueLength for the next check
     valueLength = values.length;
@@ -752,15 +760,15 @@
   {id}
   bind:this={slider}
   role="none"
-  class="rangeSlider"
+  class="rangeSlider {classes}"
   class:range={hasRange}
+  class:min={range === 'min'}
+  class:max={range === 'max'}
   class:disabled
   class:hoverable
   class:vertical
   class:reversed
   class:focus
-  class:min={range === 'min'}
-  class:max={range === 'max'}
   class:pips
   class:pip-labels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}
   on:mousedown={sliderInteractStart}

commit 6be3330a4ccc72d758db6379b084edded64762cf
Author: simeydotme <simey.me@gmail.com>
Date:   Fri Mar 14 01:20:20 2025 +0800

    move component tests to playwright, unit tests in vitest
    
    - add a github workflow

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index d01addc..52a1597 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -172,6 +172,9 @@
   $: ariaLabels, checkAriaLabels();
   $: min, checkMinMax();
   $: max, checkMinMax();
+  $: hasRange =
+    (range === true && values.length === 2) ||
+    ((range === 'min' || range === 'max') && values.length === 1);
 
   $: {
     // trim the range so it remains as a min/max (only 2 handles)
@@ -750,7 +753,7 @@
   bind:this={slider}
   role="none"
   class="rangeSlider"
-  class:range
+  class:range={hasRange}
   class:disabled
   class:hoverable
   class:vertical
@@ -806,7 +809,7 @@
              {orientationEnd}: {100 - valueAsPercent(limits[1], min, max, precision)}%;"
     />
   {/if}
-  {#if range}
+  {#if hasRange}
     <span
       class="rangeBar"
       class:rangeDrag={draggy}

commit d1c86e7090577406d104c9b1fbb4bd7b78fcfd69
Author: simeydotme <simey.me@gmail.com>
Date:   Wed Mar 12 20:44:24 2025 +0800

    only show hover if hoverable && !disabled

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index e1b2cea..d01addc 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -1044,6 +1044,7 @@
     font-size: 0.9em;
     padding: 0.2em 0.4em;
     border-radius: 0.2em;
+    z-index: 3;
   }
 
   :global(.rangeSlider .rangeHandle.active .rangeFloat),
@@ -1088,11 +1089,11 @@
       scale 0.2s ease;
   }
 
-  :global(.rangeSlider .rangeBar.rangeDrag:hover::before) {
+  :global(.rangeSlider.hoverable:not(.disabled) .rangeDrag:hover::before) {
     opacity: 0.2;
   }
 
-  :global(.rangeSlider .rangeBar.rangeDrag.press::before) {
+  :global(.rangeSlider.hoverable:not(.disabled) .rangeDrag.press::before) {
     opacity: 0.4;
     scale: 1 1.25;
   }

commit d631a69204b03dc32c1b6d542d36822a7dfcc27a
Author: simeydotme <simey.me@gmail.com>
Date:   Wed Mar 12 20:21:49 2025 +0800

    add checks for precision and min<max
    
    - fix min/max if they are wrong
    - also try to fix aria labels if it's wrong

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 9bf73a7..e1b2cea 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -19,6 +19,9 @@
   // dom references
   export let slider: HTMLDivElement | undefined = undefined;
 
+  // precision prop
+  export let precision: number = 2;
+
   // range slider props
   export let range: boolean | 'min' | 'max' = false;
   export let pushy: boolean = false;
@@ -26,7 +29,7 @@
   export let min: number = 0;
   export let max: number = 100;
   export let step: number = 1;
-  export let values: number[] = [(max + min) / 2];
+  export let values: number[] = [coerceFloat((max + min) / 2, precision)];
   export let value: number = values[0];
   export let vertical: boolean = false;
   export let float: boolean = false;
@@ -56,7 +59,6 @@
   export let ariaLabels: string[] = [];
 
   // stylistic props
-  export let precision: number = 2;
   export let springValues: SpringOpts = { stiffness: 0.15, damping: 0.4 };
 
   // prepare dispatched events
@@ -111,8 +113,17 @@
     }
   };
 
+  const checkMinMax = () => {
+    if (min >= max) {
+      min = 0;
+      max = 100;
+      console.error("'min' prop should be less than 'max'");
+    }
+  };
+
   const checkAriaLabels = () => {
     if (values.length > 1 && !Array.isArray(ariaLabels)) {
+      ariaLabels = [];
       console.warn(`'ariaLabels' prop should be an Array`);
     }
   };
@@ -153,11 +164,14 @@
   checkValueIsNumber();
   checkValuesIsArray();
   checkValuesAgainstRangeGaps();
+  checkMinMax();
 
   // keep value and values in sync with each other
   $: value, updateValues();
   $: values, updateValue();
   $: ariaLabels, checkAriaLabels();
+  $: min, checkMinMax();
+  $: max, checkMinMax();
 
   $: {
     // trim the range so it remains as a min/max (only 2 handles)

commit 8d809dda6af551ad5fe763ab1e5477cb687ab071
Author: simeydotme <simey.me@gmail.com>
Date:   Wed Mar 12 18:12:33 2025 +0800

    fix how 1% and 10% are calculated for keyboard interactions
    
    - also fix PgUp and PgDown (they were inverted by accident)
    - resolves #152

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 4efaf97..9bf73a7 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -513,31 +513,23 @@
       const handle = elementIndex(event.target as HTMLSpanElement);
       let jump = step;
       if (event.ctrlKey || event.metaKey) {
-        jump = clampValue(
-          (max - min) / step / 100,
-          coerceFloat(jump, precision),
-          coerceFloat((max - min) / 100, precision)
-        );
-        // ~ 1%
-      } else if (event.shiftKey) {
-        // ~ 10%
-        jump = clampValue(
-          (max - min) / step / 10,
-          coerceFloat(jump, precision),
-          coerceFloat((max - min) / 10, precision)
-        );
+        // Move by 1% of the total range, but ensure it's aligned to step
+        const onePercent = (max - min) / 100;
+        jump = Math.max(step, Math.round(onePercent / step) * step);
+      } else if (event.shiftKey || event.key === 'PageUp' || event.key === 'PageDown') {
+        // Move by 10% of the total range, but ensure it's aligned to step
+        const tenPercent = (max - min) / 10;
+        jump = Math.max(step, Math.round(tenPercent / step) * step);
       }
 
       switch (event.key) {
-        case 'PageDown':
-          jump *= 10;
+        case 'PageUp':
         case 'ArrowRight':
         case 'ArrowUp':
           moveHandle(handle, values[handle] + coerceFloat(jump, precision));
           prevent = true;
           break;
-        case 'PageUp':
-          jump *= 10;
+        case 'PageDown':
         case 'ArrowLeft':
         case 'ArrowDown':
           moveHandle(handle, values[handle] - coerceFloat(jump, precision));

commit a473ef7fe3adc6d16ee783260035f6e43d031e63
Author: simeydotme <simey.me@gmail.com>
Date:   Mon Mar 10 00:57:43 2025 +0800

    add new property; "draggy"
    
    - allows the user to drag the 'range' area between two handles
            - only works on a range slider
    
    notes;
    -----
    
    there is a fairly different event payload when firing start/stop/change
    on a range-drag event as opposed to the normal handle-move event

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index dfdbb00..4efaf97 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -22,6 +22,7 @@
   // range slider props
   export let range: boolean | 'min' | 'max' = false;
   export let pushy: boolean = false;
+  export let draggy: boolean = false;
   export let min: number = 0;
   export let max: number = 100;
   export let step: number = 1;
@@ -66,10 +67,13 @@
   let focus = false;
   let handleActivated = false;
   let handlePressed = false;
+  let rangeActivated = false;
+  let rangePressed = false;
+  let activeRangeGaps = [1, 1];
   let keyboardActive = false;
-  let activeHandle = values.length - 1;
-  let startValue: number;
-  let previousValue: number;
+  let activeHandle = -1;
+  let startValues: (number | undefined)[] = [];
+  let previousValues: (number | undefined)[] = [];
 
   // copy the initial values in to a spring function which
   // will update every time the values array is modified
@@ -118,13 +122,27 @@
     values = values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits));
     // then, check the values against the range gaps
     if (rangeGapMax < Infinity) {
-      const gapMax = constrainAndAlignValue(values[0] + rangeGapMax, min, max, step, precision, limits);
+      const gapMax = constrainAndAlignValue(
+        values[0] + rangeGapMax,
+        min,
+        max,
+        step,
+        precision,
+        limits
+      );
       if (values[1] > gapMax) {
         values[1] = gapMax;
       }
     }
     if (rangeGapMin > 0) {
-      const gapMin = constrainAndAlignValue(values[0] + rangeGapMin, min, max, step, precision, limits);
+      const gapMin = constrainAndAlignValue(
+        values[0] + rangeGapMin,
+        min,
+        max,
+        step,
+        precision,
+        limits
+      );
       if (values[1] < gapMin) {
         values[1] = gapMin;
       }
@@ -175,8 +193,6 @@
     valueLength = values.length;
   }
 
-  
-
   /**
    * the orientation of the handles/pips based on the
    * input values of vertical and reversed
@@ -282,7 +298,7 @@
    * @param {object} clientPos the client {x,y} of the interaction
    **/
   function handleInteract(clientPos: NormalisedClient) {
-    if (!slider) return;
+    if (!slider || !handleActivated) return;
     // first make sure we have the latest dimensions
     // of the slider, as it may have changed size
     const dims = slider.getBoundingClientRect();
@@ -304,13 +320,64 @@
     moveHandle(activeHandle, handleVal);
   }
 
+  function getRangeGapsOnInteractionStart(clientPos: NormalisedClient) {
+    if (!slider || !draggy || !rangeActivated || range === 'min' || range === 'max') return;
+    const dims = slider.getBoundingClientRect();
+    let pointerPos = 0;
+    let pointerPercent = 0;
+    let pointerVal = 0;
+    if (vertical) {
+      pointerPos = clientPos.y - dims.top;
+      pointerPercent = (pointerPos / dims.height) * 100;
+      pointerPercent = reversed ? pointerPercent : 100 - pointerPercent;
+    } else {
+      pointerPos = clientPos.x - dims.left;
+      pointerPercent = (pointerPos / dims.width) * 100;
+      pointerPercent = reversed ? 100 - pointerPercent : pointerPercent;
+    }
+    pointerVal = ((max - min) / 100) * pointerPercent + min;
+    activeRangeGaps = [values[0] - pointerVal, values[1] - pointerVal];
+  }
+
+  /**
+   * take the interaction position on the slider, get the values of each handle
+   * then calculate the distance between the handles and the interaction position
+   * so when the user moves the range, each handle moves in the corresponding direction
+   * at the original distance from the interaction position
+   * @param {object} clientPos the client {x,y} of the interaction
+   */
+  function rangeInteract(clientPos: NormalisedClient) {
+    if (!slider || !draggy || !rangeActivated || range === 'min' || range === 'max') return;
+    // first make sure we have the latest dimensions
+    // of the slider, as it may have changed size
+    const dims = slider.getBoundingClientRect();
+    // calculate the interaction position, percent and value
+    let pointerPos = 0;
+    let pointerPercent = 0;
+    let pointerVal = 0;
+    if (vertical) {
+      pointerPos = clientPos.y - dims.top;
+      pointerPercent = (pointerPos / dims.height) * 100;
+      pointerPercent = reversed ? pointerPercent : 100 - pointerPercent;
+    } else {
+      pointerPos = clientPos.x - dims.left;
+      pointerPercent = (pointerPos / dims.width) * 100;
+      pointerPercent = reversed ? 100 - pointerPercent : pointerPercent;
+    }
+    pointerVal = ((max - min) / 100) * pointerPercent + min;
+    activeHandle = -1;
+    moveHandle(0, pointerVal + activeRangeGaps[0], false);
+    moveHandle(1, pointerVal + activeRangeGaps[1], true);
+  }
+
   /**
    * move a handle to a specific value, respecting the clamp/align rules
    * @param {number} index the index of the handle we want to move
    * @param {number} value the value to move the handle to
+   * @param {boolean} fireEvent whether to fire the change event
    * @return {number} the value that was moved to (after alignment/clamping)
    **/
-  function moveHandle(index: number | null, value: number) {
+  function moveHandle(index: number | null, value: number, fireEvent: boolean = true) {
     // align & clamp the value so we're not doing extra
     // calculation on an out-of-range value down below
     value = constrainAndAlignValue(value, min, max, step, precision, limits);
@@ -357,14 +424,25 @@
     if (values[index] !== value) {
       constrainAndAlignValue((values[index] = value), min, max, step, precision, limits);
     }
+    if (fireEvent) {
+      fireChangeEvent(values);
+    }
+    return value;
+  }
+
+  /**
+   *
+   */
+  function fireChangeEvent(values: number[]) {
+    // Check if any value has changed by comparing each element
+    const hasChanged = previousValues.some((prev, index) => {
+      return prev !== values[index];
+    });
 
-    // fire the change event when the handle moves,
-    // and store the previous value for the next time
-    if (previousValue !== value) {
+    if (hasChanged) {
       eChange();
-      previousValue = value;
+      previousValues = [...values];
     }
-    return value;
   }
 
   /**
@@ -406,6 +484,8 @@
       focus = false;
       handleActivated = false;
       handlePressed = false;
+      rangeActivated = false;
+      rangePressed = false;
     }
   }
 
@@ -490,26 +570,28 @@
       const clientPos = normalisedClient(event);
       // set the closest handle as active
       focus = true;
-      handleActivated = true;
-      handlePressed = true;
-      activeHandle = getClosestHandle(clientPos);
 
+      if (target.matches('.rangeBar') && range === true && draggy) {
+        handleActivated = false;
+        handlePressed = false;
+        activeHandle = -1;
+        rangeActivated = true;
+        rangePressed = true;
+        getRangeGapsOnInteractionStart(clientPos);
+      } else {
+        handleActivated = true;
+        handlePressed = true;
+        activeHandle = getClosestHandle(clientPos);
+        // for touch devices we want the handle to instantly
+        // move to the position touched for more responsive feeling
+        if (event.type === 'touchstart' && !target.matches('.pipVal')) {
+          handleInteract(clientPos);
+        }
+      }
       // fire the start event
-      startValue = previousValue = constrainAndAlignValue(
-        values[activeHandle],
-        min,
-        max,
-        step,
-        precision,
-        limits
-      );
+      startValues = values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits));
+      previousValues = [...startValues];
       eStart();
-
-      // for touch devices we want the handle to instantly
-      // move to the position touched for more responsive feeling
-      if (event.type === 'touchstart' && !target.matches('.pipVal')) {
-        handleInteract(clientPos);
-      }
     }
   }
 
@@ -524,6 +606,7 @@
       eStop();
     }
     handlePressed = false;
+    rangePressed = false;
   }
 
   /**
@@ -548,6 +631,8 @@
     if (!disabled) {
       if (handleActivated) {
         handleInteract(normalisedClient(event));
+      } else if (rangeActivated) {
+        rangeInteract(normalisedClient(event));
       }
     }
   }
@@ -573,13 +658,17 @@
             handleInteract(normalisedClient(event));
           }
         }
+      }
+      if (handleActivated || rangeActivated) {
         // fire the stop event for mouse device
-        // when the body is triggered with an active handle
+        // when the body is triggered with an active handle/range
         eStop();
       }
     }
     handleActivated = false;
     handlePressed = false;
+    rangeActivated = false;
+    rangePressed = false;
   }
 
   /**
@@ -590,6 +679,8 @@
   function bodyTouchEnd(event: TouchEvent) {
     handleActivated = false;
     handlePressed = false;
+    rangeActivated = false;
+    rangePressed = false;
   }
 
   function bodyKeyDown(event: KeyboardEvent) {
@@ -602,33 +693,41 @@
   }
 
   function eStart() {
-    !disabled &&
-      dispatch('start', {
-        activeHandle,
-        value: startValue,
-        values: values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits))
-      });
+    if (disabled) return;
+    dispatch('start', {
+      activeHandle,
+      value: startValues[activeHandle],
+      values: startValues
+    });
   }
 
   function eStop() {
-    !disabled &&
-      dispatch('stop', {
-        activeHandle,
-        startValue: startValue,
-        value: values[activeHandle],
-        values: values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits))
-      });
+    if (disabled) return;
+    const startValue = rangeActivated ? startValues : startValues[activeHandle];
+    dispatch('stop', {
+      activeHandle,
+      startValue,
+      value: values[activeHandle],
+      values: values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits))
+    });
   }
 
   function eChange() {
-    !disabled &&
-      dispatch('change', {
-        activeHandle,
-        startValue: startValue,
-        previousValue: typeof previousValue === 'undefined' ? startValue : previousValue,
-        value: values[activeHandle],
-        values: values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits))
-      });
+    if (disabled) return;
+    const startValue = rangeActivated ? startValues : startValues[activeHandle];
+    const previousValue =
+      typeof previousValues === 'undefined'
+        ? startValue
+        : rangeActivated
+          ? previousValues
+          : previousValues[activeHandle];
+    dispatch('change', {
+      activeHandle,
+      startValue,
+      previousValue,
+      value: values[activeHandle],
+      values: values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits))
+    });
   }
 
   function ariaLabelFormatter(value: number, index: number) {
@@ -704,8 +803,9 @@
   {#if range}
     <span
       class="rangeBar"
-      class:rangeMax={range === true && values[1] - values[0] >= rangeGapMax}
-      class:rangeMin={range === true && values[1] - values[0] <= rangeGapMin}
+      class:rangeDrag={draggy}
+      class:press={rangePressed}
+      class:range
       style="{orientationStart}: {rangeStart($springPositions)}%; 
              {orientationEnd}: {rangeEnd($springPositions)}%;"
     >
@@ -782,6 +882,8 @@
     --range-inactive: var(--range-range-inactive, var(--handle-inactive));
     --range: var(--range-range, var(--handle-focus));
     --range-limit: var(--range-range-limit, #b9c2c2);
+    --range-hover: var(--range-range-hover, var(--handle-border));
+    --range-press: var(--range-range-press, var(--handle-border));
     --float-inactive: var(--range-float-inactive, var(--handle-inactive));
     --float: var(--range-float, var(--handle-focus));
     --float-text: var(--range-float-text, white);
@@ -948,6 +1050,7 @@
   }
 
   :global(.rangeSlider .rangeBar),
+  :global(.rangeSlider .rangeBar.rangeDrag::before),
   :global(.rangeSlider .rangeLimit) {
     position: absolute;
     display: block;
@@ -960,11 +1063,34 @@
   }
 
   :global(.rangeSlider.vertical .rangeBar),
+  :global(.rangeSlider.vertical .rangeBar.rangeDrag::before),
   :global(.rangeSlider.vertical .rangeLimit) {
     width: 0.5em;
     height: auto;
   }
 
+  :global(.rangeSlider .rangeBar.rangeDrag::before) {
+    content: '';
+    inset: 0;
+    top: -0.5em;
+    bottom: -0.5em;
+    height: auto;
+    background-color: var(--range-hover);
+    opacity: 0;
+    transition:
+      opacity 0.2s ease,
+      scale 0.2s ease;
+  }
+
+  :global(.rangeSlider .rangeBar.rangeDrag:hover::before) {
+    opacity: 0.2;
+  }
+
+  :global(.rangeSlider .rangeBar.rangeDrag.press::before) {
+    opacity: 0.4;
+    scale: 1 1.25;
+  }
+
   :global(.rangeSlider) {
     background-color: #d7dada;
     background-color: var(--slider);

commit 807a2ae6136a23b20e0b58bd6350ab30ef8b7788
Author: simeydotme <simey.me@gmail.com>
Date:   Sun Mar 2 23:13:54 2025 +0800

    add new range properties (rangeGapMin, rangeGapMax, rangeFloat,
    rangeFormatter)
    
    - `rangeGapMin`
      - allows a minumum distance to be set between handles in a range
      - respects `pushy` option (this should be the preferred usage for
    usability)
    
    - `rangeGapMax`
      - allows a maximum distance btween the handles to be constrained
      - respects `pushy` option (technically this becomes 'pully', but,
    semantics)
    
    - `rangeFloat`
      - allow a float to be shown on the range (between the handles)
      - defaults to `false`
      - will show the range of values by default (eg: `20 - 80`)
      - respects `prefix`/`suffix`
        - will append/prepend to both parts (eg: `$20 - $80`)
    
    - `rangeFormatter()`
      - function to format the `rangeFloat`
      - slightly different argument signature than `formatter()`
      - signature is; `(value1, value2, percent1, percent2)`

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 074847c..dfdbb00 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -7,12 +7,12 @@
     coerceFloat,
     valueAsPercent,
     clampValue,
-    alignValueToStep,
+    constrainAndAlignValue,
     pureText,
     normalisedClient,
     elementIndex
   } from '$lib/utils.js';
-  import type { Pip, Formatter, NormalisedClient } from '$lib/types.js';
+  import type { Pip, Formatter, NormalisedClient, RangeFormatter } from '$lib/types.js';
 
   import RangePips from './RangePips.svelte';
 
@@ -29,10 +29,13 @@
   export let value: number = values[0];
   export let vertical: boolean = false;
   export let float: boolean = false;
+  export let rangeFloat: boolean = false;
   export let reversed: boolean = false;
   export let hoverable: boolean = true;
   export let disabled: boolean = false;
   export let limits: null | [number, number] = null;
+  export let rangeGapMin: number = 0;
+  export let rangeGapMax: number = Infinity;
 
   // range pips / values props
   export let pips: boolean = false;
@@ -47,7 +50,8 @@
   export let prefix: string = '';
   export let suffix: string = '';
   export let formatter: Formatter = (v, i, p) => v;
-  export let handleFormatter = formatter;
+  export let handleFormatter: Formatter = formatter;
+  export let rangeFormatter: RangeFormatter | null = null;
   export let ariaLabels: string[] = [];
 
   // stylistic props
@@ -109,9 +113,28 @@
     }
   };
 
+  const checkValuesAgainstRangeGaps = () => {
+    // first, align the values to the step
+    values = values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits));
+    // then, check the values against the range gaps
+    if (rangeGapMax < Infinity) {
+      const gapMax = constrainAndAlignValue(values[0] + rangeGapMax, min, max, step, precision, limits);
+      if (values[1] > gapMax) {
+        values[1] = gapMax;
+      }
+    }
+    if (rangeGapMin > 0) {
+      const gapMin = constrainAndAlignValue(values[0] + rangeGapMin, min, max, step, precision, limits);
+      if (values[1] < gapMin) {
+        values[1] = gapMin;
+      }
+    }
+  };
+
   // fixup the value/values at render
   checkValueIsNumber();
   checkValuesIsArray();
+  checkValuesAgainstRangeGaps();
 
   // keep value and values in sync with each other
   $: value, updateValues();
@@ -122,7 +145,7 @@
     // trim the range so it remains as a min/max (only 2 handles)
     // and also align the handles to the steps
     const trimmedAlignedValues = trimRange(
-      values.map((v) => alignValueToStep(v, min, max, step, precision, limits))
+      values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits))
     );
     if (
       !(values.length === trimmedAlignedValues.length) ||
@@ -152,6 +175,8 @@
     valueLength = values.length;
   }
 
+  
+
   /**
    * the orientation of the handles/pips based on the
    * input values of vertical and reversed
@@ -288,33 +313,49 @@
   function moveHandle(index: number | null, value: number) {
     // align & clamp the value so we're not doing extra
     // calculation on an out-of-range value down below
-    value = alignValueToStep(value, min, max, step, precision, limits);
+    value = constrainAndAlignValue(value, min, max, step, precision, limits);
     // use the active handle if handle index is not provided
     if (index === null) {
       index = activeHandle;
     }
     // if this is a range slider perform special checks
-    if (range) {
+    if (range === true) {
       // restrict the handles of a range-slider from
       // going past one-another unless "pushy" is true
-      if (index === 0 && value > values[1]) {
-        if (pushy) {
-          values[1] = value;
-        } else {
-          value = values[1];
+      if (index === 0) {
+        if (value > values[1] - rangeGapMin) {
+          if (pushy && value < (limits?.[1] ?? max) - rangeGapMin) {
+            values[1] = value + rangeGapMin;
+          } else {
+            value = values[1] - rangeGapMin;
+          }
+        } else if (value < values[1] - rangeGapMax) {
+          if (pushy) {
+            values[1] = value + rangeGapMax;
+          } else {
+            value = values[1] - rangeGapMax;
+          }
         }
-      } else if (index === 1 && value < values[0]) {
-        if (pushy) {
-          values[0] = value;
-        } else {
-          value = values[0];
+      } else if (index === 1) {
+        if (value < values[0] + rangeGapMin) {
+          if (pushy && value > (limits?.[0] ?? min) + rangeGapMin) {
+            values[0] = value - rangeGapMin;
+          } else {
+            value = values[0] + rangeGapMin;
+          }
+        } else if (value > values[0] + rangeGapMax) {
+          if (pushy) {
+            values[0] = value - rangeGapMax;
+          } else {
+            value = values[0] + rangeGapMax;
+          }
         }
       }
     }
 
     // if the value has changed, update it
     if (values[index] !== value) {
-      values[index] = value;
+      constrainAndAlignValue((values[index] = value), min, max, step, precision, limits);
     }
 
     // fire the change event when the handle moves,
@@ -454,7 +495,7 @@
       activeHandle = getClosestHandle(clientPos);
 
       // fire the start event
-      startValue = previousValue = alignValueToStep(
+      startValue = previousValue = constrainAndAlignValue(
         values[activeHandle],
         min,
         max,
@@ -565,7 +606,7 @@
       dispatch('start', {
         activeHandle,
         value: startValue,
-        values: values.map((v) => alignValueToStep(v, min, max, step, precision, limits))
+        values: values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits))
       });
   }
 
@@ -575,7 +616,7 @@
         activeHandle,
         startValue: startValue,
         value: values[activeHandle],
-        values: values.map((v) => alignValueToStep(v, min, max, step, precision, limits))
+        values: values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits))
       });
   }
 
@@ -586,7 +627,7 @@
         startValue: startValue,
         previousValue: typeof previousValue === 'undefined' ? startValue : previousValue,
         value: values[activeHandle],
-        values: values.map((v) => alignValueToStep(v, min, max, step, precision, limits))
+        values: values.map((v) => constrainAndAlignValue(v, min, max, step, precision, limits))
       });
   }
 
@@ -663,9 +704,31 @@
   {#if range}
     <span
       class="rangeBar"
+      class:rangeMax={range === true && values[1] - values[0] >= rangeGapMax}
+      class:rangeMin={range === true && values[1] - values[0] <= rangeGapMin}
       style="{orientationStart}: {rangeStart($springPositions)}%; 
              {orientationEnd}: {rangeEnd($springPositions)}%;"
-    />
+    >
+      {#if rangeFloat}
+        <span class="rangeFloat">
+          {#if rangeFormatter}
+            {@html rangeFormatter(
+              values[0],
+              values[1],
+              valueAsPercent(values[0], min, max, precision),
+              valueAsPercent(values[1], min, max, precision)
+            )}
+          {:else}
+            {@const [first, second] = reversed ? [values[1], values[0]] : [values[0], values[1]]}
+            {#if prefix}<span class="rangeFloat-prefix">{prefix}</span
+              >{/if}{@html first}{#if suffix}<span class="rangeFloat-suffix">{suffix}</span>{/if}
+            {' '}-{' '}
+            {#if prefix}<span class="rangeFloat-prefix">{prefix}</span
+              >{/if}{@html second}{#if suffix}<span class="rangeFloat-suffix">{suffix}</span>{/if}
+          {/if}
+        </span>
+      {/if}
+    </span>
   {/if}
   {#if pips}
     <RangePips
@@ -876,7 +939,9 @@
   }
 
   :global(.rangeSlider .rangeHandle.active .rangeFloat),
-  :global(.rangeSlider.hoverable .rangeHandle:hover .rangeFloat) {
+  :global(.rangeSlider.hoverable .rangeHandle:hover .rangeFloat),
+  :global(.rangeSlider.hoverable:hover .rangeBar .rangeFloat),
+  :global(.rangeSlider.focus .rangeBar .rangeFloat) {
     opacity: 1;
     top: -0.2em;
     transform: translate(-50%, -100%);

commit 4f15bc8ae44e6c66ec2dc43b511620a69ae42614
Author: simeydotme <simey.me@gmail.com>
Date:   Sun Feb 23 13:48:11 2025 +0800

    fix css variables

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index bff1e23..61fc440 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -178,8 +178,8 @@
     --pip-hover-text: var(--range-pip-hover-text, var(--pip-hover));
     --pip-in-range: var(--range-pip-in-range, var(--pip-active));
     --pip-in-range-text: var(--range-pip-in-range-text, var(--pip-active-text));
-    --pip-out-of-range: var(--range-pip-out-of-range, #aebecf);
-    --pip-out-of-range-text: var(--range-pip-out-of-range-text, var(--pip-out-of-range));
+    --pip-out-of-limit: var(--range-pip-out-of-limit, #aebecf);
+    --pip-out-of-limit-text: var(--range-pip-out-of-limit-text, var(--pip-out-of-limit));
   }
 
   :global(.rangePips) {
@@ -270,9 +270,9 @@
 
   :global(.rangePips .pip.out-of-limit) {
     color: #aebecf;
-    color: var(--pip-out-of-range-text);
+    color: var(--pip-out-of-limit-text);
     background-color: #aebecf;
-    background-color: var(--pip-out-of-range);
+    background-color: var(--pip-out-of-limit);
   }
 
   :global(.rangePips .pip.selected) {
diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 187d74e..074847c 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -718,7 +718,7 @@
     --handle-border: var(--range-handle-border, var(--handle));
     --range-inactive: var(--range-range-inactive, var(--handle-inactive));
     --range: var(--range-range, var(--handle-focus));
-    --range-limit: var(--range-range-limit, #99a2a280);
+    --range-limit: var(--range-range-limit, #b9c2c2);
     --float-inactive: var(--range-float-inactive, var(--handle-inactive));
     --float: var(--range-float, var(--handle-focus));
     --float-text: var(--range-float-text, white);

commit c6323c05cc7638bb59825a90db4eac0ee2423145
Author: simeydotme <simey.me@gmail.com>
Date:   Sun Feb 23 11:30:36 2025 +0800

    add some unique styling for pips outside of limits

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index a4b07bd..bff1e23 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -5,7 +5,8 @@
     normalisedClient,
     isInRange,
     isSelected,
-    getValueFromIndex
+    getValueFromIndex,
+    isOutOfLimit
   } from '$lib/utils.js';
   import type { Pip, Formatter, NormalisedClient } from '$lib/types.js';
 
@@ -20,6 +21,7 @@
   export let reversed: boolean = false;
   export let hoverable: boolean = true;
   export let disabled: boolean = false;
+  export let limits: null | [number, number] = null;
 
   // range pips / values props
   export let pipstep: number | undefined = undefined;
@@ -86,6 +88,7 @@
       class="pip first"
       class:selected={isSelected(min, values, precision)}
       class:in-range={isInRange(min, values, range)}
+      class:out-of-limit={isOutOfLimit(min, limits)}
       style="{orientationStart}: 0%;"
       data-val={coerceFloat(min, precision)}
       on:pointerdown={(e) => {
@@ -113,6 +116,7 @@
           class="pip"
           class:selected={isSelected(val, values, precision)}
           class:in-range={isInRange(val, values, range)}
+          class:out-of-limit={isOutOfLimit(val, limits)}
           style="{orientationStart}: {valueAsPercent(val, min, max, precision)}%;"
           data-val={val}
           on:pointerdown={(e) => {
@@ -139,6 +143,7 @@
       class="pip last"
       class:selected={isSelected(max, values, precision)}
       class:in-range={isInRange(max, values, range)}
+      class:out-of-limit={isOutOfLimit(max, limits)}
       style="{orientationStart}: 100%;"
       data-val={coerceFloat(max, precision)}
       on:pointerdown={(e) => {
@@ -173,6 +178,8 @@
     --pip-hover-text: var(--range-pip-hover-text, var(--pip-hover));
     --pip-in-range: var(--range-pip-in-range, var(--pip-active));
     --pip-in-range-text: var(--range-pip-in-range-text, var(--pip-active-text));
+    --pip-out-of-range: var(--range-pip-out-of-range, #aebecf);
+    --pip-out-of-range-text: var(--range-pip-out-of-range-text, var(--pip-out-of-range));
   }
 
   :global(.rangePips) {
@@ -247,7 +254,7 @@
     background-color: var(--pip-active);
   }
 
-  :global(.rangePips.hoverable:not(.disabled) .pip:hover) {
+  :global(.rangePips.hoverable:not(.disabled) .pip:not(.out-of-limit):hover) {
     color: darkslategrey;
     color: var(--pip-hover-text);
     background-color: darkslategrey;
@@ -261,6 +268,13 @@
     background-color: var(--pip-in-range);
   }
 
+  :global(.rangePips .pip.out-of-limit) {
+    color: #aebecf;
+    color: var(--pip-out-of-range-text);
+    background-color: #aebecf;
+    background-color: var(--pip-out-of-range);
+  }
+
   :global(.rangePips .pip.selected) {
     height: 0.75em;
   }
@@ -280,11 +294,13 @@
     left: 0.75em;
   }
 
-  :global(.rangePips.hoverable:not(.disabled) .pip:not(.selected):hover) {
+  :global(.rangePips.hoverable:not(.disabled) .pip:not(.selected):not(.out-of-limit):hover) {
     transition: none;
   }
 
-  :global(.rangePips.hoverable:not(.disabled) .pip:not(.selected):hover .pipVal) {
+  :global(
+      .rangePips.hoverable:not(.disabled) .pip:not(.selected):not(.out-of-limit):hover .pipVal
+    ) {
     transition: none;
     font-weight: bold;
   }
diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 3e7d48a..187d74e 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -679,6 +679,7 @@
       {orientationStart}
       {hoverable}
       {disabled}
+      {limits}
       {all}
       {first}
       {last}

commit 83fd6c57fb5e24cc42f1a400c51f4eaea6b71b11
Author: simeydotme <simey.me@gmail.com>
Date:   Sun Feb 23 09:28:00 2025 +0800

    add the new property 'limits' to the library
    
    - allows setting a limit other than min/max where the handles will stop

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 743673a..3e7d48a 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -32,6 +32,7 @@
   export let reversed: boolean = false;
   export let hoverable: boolean = true;
   export let disabled: boolean = false;
+  export let limits: null | [number, number] = null;
 
   // range pips / values props
   export let pips: boolean = false;
@@ -121,7 +122,7 @@
     // trim the range so it remains as a min/max (only 2 handles)
     // and also align the handles to the steps
     const trimmedAlignedValues = trimRange(
-      values.map((v) => alignValueToStep(v, min, max, step, precision))
+      values.map((v) => alignValueToStep(v, min, max, step, precision, limits))
     );
     if (
       !(values.length === trimmedAlignedValues.length) ||
@@ -287,7 +288,7 @@
   function moveHandle(index: number | null, value: number) {
     // align & clamp the value so we're not doing extra
     // calculation on an out-of-range value down below
-    value = alignValueToStep(value, min, max, step, precision);
+    value = alignValueToStep(value, min, max, step, precision, limits);
     // use the active handle if handle index is not provided
     if (index === null) {
       index = activeHandle;
@@ -458,7 +459,8 @@
         min,
         max,
         step,
-        precision
+        precision,
+        limits
       );
       eStart();
 
@@ -563,7 +565,7 @@
       dispatch('start', {
         activeHandle,
         value: startValue,
-        values: values.map((v) => alignValueToStep(v, min, max, step, precision))
+        values: values.map((v) => alignValueToStep(v, min, max, step, precision, limits))
       });
   }
 
@@ -573,7 +575,7 @@
         activeHandle,
         startValue: startValue,
         value: values[activeHandle],
-        values: values.map((v) => alignValueToStep(v, min, max, step, precision))
+        values: values.map((v) => alignValueToStep(v, min, max, step, precision, limits))
       });
   }
 
@@ -584,7 +586,7 @@
         startValue: startValue,
         previousValue: typeof previousValue === 'undefined' ? startValue : previousValue,
         value: values[activeHandle],
-        values: values.map((v) => alignValueToStep(v, min, max, step, precision))
+        values: values.map((v) => alignValueToStep(v, min, max, step, precision, limits))
       });
   }
 
@@ -651,6 +653,13 @@
       {/if}
     </span>
   {/each}
+  {#if limits}
+    <span
+      class="rangeLimit"
+      style="{orientationStart}: {valueAsPercent(limits[0], min, max, precision)}%;
+             {orientationEnd}: {100 - valueAsPercent(limits[1], min, max, precision)}%;"
+    />
+  {/if}
   {#if range}
     <span
       class="rangeBar"
@@ -708,6 +717,7 @@
     --handle-border: var(--range-handle-border, var(--handle));
     --range-inactive: var(--range-range-inactive, var(--handle-inactive));
     --range: var(--range-range, var(--handle-focus));
+    --range-limit: var(--range-range-limit, #99a2a280);
     --float-inactive: var(--range-float-inactive, var(--handle-inactive));
     --float: var(--range-float, var(--handle-focus));
     --float-text: var(--range-float-text, white);
@@ -871,7 +881,8 @@
     transform: translate(-50%, -100%);
   }
 
-  :global(.rangeSlider .rangeBar) {
+  :global(.rangeSlider .rangeBar),
+  :global(.rangeSlider .rangeLimit) {
     position: absolute;
     display: block;
     transition: background 0.2s ease;
@@ -882,7 +893,8 @@
     z-index: 1;
   }
 
-  :global(.rangeSlider.vertical .rangeBar) {
+  :global(.rangeSlider.vertical .rangeBar),
+  :global(.rangeSlider.vertical .rangeLimit) {
     width: 0.5em;
     height: auto;
   }
@@ -902,6 +914,11 @@
     background-color: var(--range);
   }
 
+  :global(.rangeSlider .rangeLimit) {
+    background-color: #99a2a280;
+    background-color: var(--range-limit);
+  }
+
   :global(.rangeSlider .rangeNub) {
     background-color: #99a2a2;
     background-color: var(--handle-inactive);

commit 6db44a141745ebb581d37fd284dbae1572907334
Author: simeydotme <simey.me@gmail.com>
Date:   Sat Oct 26 02:19:23 2024 +0800

    fix issue with precision on decimals
    
    - incorporate syntax improvements from @3commascapital in  #151

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index 7b8ae58..a4b07bd 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -36,7 +36,7 @@
 
   // stylistic props
   export let focus: boolean;
-  export let orientationStart: string;
+  export let orientationStart: 'left' | 'right' | 'top' | 'bottom';
 
   // methods
   export let moveHandle: (index: number | null, value: number) => void;
@@ -87,6 +87,7 @@
       class:selected={isSelected(min, values, precision)}
       class:in-range={isInRange(min, values, range)}
       style="{orientationStart}: 0%;"
+      data-val={coerceFloat(min, precision)}
       on:pointerdown={(e) => {
         labelDown(e);
       }}
@@ -96,11 +97,9 @@
     >
       {#if all === 'label' || first === 'label'}
         <span class="pipVal">
-          {#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
-            coerceFloat(min),
-            0,
-            0
-          )}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+          {#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}
+          {@html formatter(coerceFloat(min, precision), 0, 0)}
+          {#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
         </span>
       {/if}
     </span>
@@ -108,34 +107,26 @@
 
   {#if (all && rest !== false) || rest}
     {#each Array(pipCount + 1) as _, i}
-      {#if getValueFromIndex(i, min, max, pipStep, step) !== min && getValueFromIndex(i, min, max, pipStep, step) !== max}
+      {@const val = getValueFromIndex(i, min, max, pipStep, step, precision)}
+      {#if val !== min && val !== max}
         <span
           class="pip"
-          class:selected={isSelected(
-            getValueFromIndex(i, min, max, pipStep, step),
-            values,
-            precision
-          )}
-          class:in-range={isInRange(getValueFromIndex(i, min, max, pipStep, step), values, range)}
-          style="{orientationStart}: {valueAsPercent(
-            getValueFromIndex(i, min, max, pipStep, step),
-            min,
-            max
-          )}%;"
+          class:selected={isSelected(val, values, precision)}
+          class:in-range={isInRange(val, values, range)}
+          style="{orientationStart}: {valueAsPercent(val, min, max, precision)}%;"
+          data-val={val}
           on:pointerdown={(e) => {
             labelDown(e);
           }}
           on:pointerup={(e) => {
-            labelUp(getValueFromIndex(i, min, max, pipStep, step), e);
+            labelUp(val, e);
           }}
         >
           {#if all === 'label' || rest === 'label'}
             <span class="pipVal">
-              {#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
-                getValueFromIndex(i, min, max, pipStep, step),
-                i,
-                valueAsPercent(getValueFromIndex(i, min, max, pipStep, step), min, max, precision)
-              )}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+              {#if true || prefix}<span class="pipVal-prefix">{prefix}</span>{/if}
+              {@html formatter(val, i, valueAsPercent(val, min, max, precision))}
+              {#if true || suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
             </span>
           {/if}
         </span>
@@ -149,6 +140,7 @@
       class:selected={isSelected(max, values, precision)}
       class:in-range={isInRange(max, values, range)}
       style="{orientationStart}: 100%;"
+      data-val={coerceFloat(max, precision)}
       on:pointerdown={(e) => {
         labelDown(e);
       }}
@@ -158,11 +150,9 @@
     >
       {#if all === 'label' || last === 'label'}
         <span class="pipVal">
-          {#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
-            coerceFloat(max),
-            pipCount,
-            100
-          )}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+          {#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}
+          {@html formatter(coerceFloat(max, precision), pipCount, 100)}
+          {#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
         </span>
       {/if}
     </span>
@@ -223,6 +213,7 @@
     position: absolute;
     top: 0.4em;
     transform: translate(-50%, 25%);
+    display: inline-flex;
   }
 
   :global(.rangePips.vertical .pipVal) {
diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 62bded6..743673a 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -155,8 +155,20 @@
    * the orientation of the handles/pips based on the
    * input values of vertical and reversed
    **/
-  $: orientationStart = vertical ? (reversed ? 'top' : 'bottom') : reversed ? 'right' : 'left';
-  $: orientationEnd = vertical ? (reversed ? 'bottom' : 'top') : reversed ? 'left' : 'right';
+  $: orientationStart = vertical
+    ? reversed
+      ? 'top'
+      : 'bottom'
+    : reversed
+      ? 'right'
+      : ('left' as 'left' | 'right' | 'top' | 'bottom');
+  $: orientationEnd = vertical
+    ? reversed
+      ? 'bottom'
+      : 'top'
+    : reversed
+      ? 'left'
+      : ('right' as 'left' | 'right' | 'top' | 'bottom');
 
   /**
    * check if an element is a handle on the slider

commit a33abb2209c3701810e676160bc72684ebfa87cf
Merge: 5fd4175 8aef86c
Author: Simon Goellner <simey.me@gmail.com>
Date:   Sat Aug 31 00:25:02 2024 +0800

    Merge pull request #147 from nielk/patch-1
    
    Mark RangeSlider as non-immutable

commit 8aef86c2e5ff7b24a60fa4d9f8e46589eaf4d12a
Author: Alexandre Oger <alexandre.oger@fabernovel.ey.com>
Date:   Fri Aug 30 06:37:18 2024 +0200

    Mark RangeSlider as non-immutable

diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 9cc6b3e..62bded6 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -1,3 +1,5 @@
+<svelte:options immutable={false} />
+
 <script lang="ts">
   import { type SpringOpts, type Spring, spring } from 'svelte/motion';
   import { createEventDispatcher } from 'svelte';

commit 879fb0e6ced00f3ac2c9e58618ac95fd74d9df6d
Author: simeydotme <simey.me@gmail.com>
Date:   Fri Aug 30 01:49:40 2024 +0800

    set immutable false, try to fix package exports, bump v3.1.0

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index 6a3e3de..7b8ae58 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -168,3 +168,133 @@
     </span>
   {/if}
 </div>
+
+<style>
+  /**
+   * RangePips
+   */
+
+  :global(.rangePips) {
+    --pip: var(--range-pip, lightslategray);
+    --pip-text: var(--range-pip-text, var(--pip));
+    --pip-active: var(--range-pip-active, darkslategrey);
+    --pip-active-text: var(--range-pip-active-text, var(--pip-active));
+    --pip-hover: var(--range-pip-hover, darkslategrey);
+    --pip-hover-text: var(--range-pip-hover-text, var(--pip-hover));
+    --pip-in-range: var(--range-pip-in-range, var(--pip-active));
+    --pip-in-range-text: var(--range-pip-in-range-text, var(--pip-active-text));
+  }
+
+  :global(.rangePips) {
+    position: absolute;
+    height: 1em;
+    left: 0;
+    right: 0;
+    bottom: -1em;
+    font-variant-numeric: tabular-nums;
+  }
+
+  :global(.rangePips.vertical) {
+    height: auto;
+    width: 1em;
+    left: 100%;
+    right: auto;
+    top: 0;
+    bottom: 0;
+  }
+
+  :global(.rangePips .pip) {
+    height: 0.4em;
+    position: absolute;
+    top: 0.25em;
+    width: 1px;
+    white-space: nowrap;
+  }
+
+  :global(.rangePips.vertical .pip) {
+    height: 1px;
+    width: 0.4em;
+    left: 0.25em;
+    top: auto;
+    bottom: auto;
+  }
+
+  :global(.rangePips .pipVal) {
+    position: absolute;
+    top: 0.4em;
+    transform: translate(-50%, 25%);
+  }
+
+  :global(.rangePips.vertical .pipVal) {
+    position: absolute;
+    top: 0;
+    left: 0.4em;
+    transform: translate(25%, -50%);
+  }
+
+  :global(.rangePips .pip) {
+    transition: all 0.15s ease;
+  }
+
+  :global(.rangePips .pipVal) {
+    transition:
+      all 0.15s ease,
+      font-weight 0s linear;
+  }
+
+  :global(.rangePips .pip) {
+    color: lightslategray;
+    color: var(--pip-text);
+    background-color: lightslategray;
+    background-color: var(--pip);
+  }
+
+  :global(.rangePips .pip.selected) {
+    color: darkslategrey;
+    color: var(--pip-active-text);
+    background-color: darkslategrey;
+    background-color: var(--pip-active);
+  }
+
+  :global(.rangePips.hoverable:not(.disabled) .pip:hover) {
+    color: darkslategrey;
+    color: var(--pip-hover-text);
+    background-color: darkslategrey;
+    background-color: var(--pip-hover);
+  }
+
+  :global(.rangePips .pip.in-range) {
+    color: darkslategrey;
+    color: var(--pip-in-range-text);
+    background-color: darkslategrey;
+    background-color: var(--pip-in-range);
+  }
+
+  :global(.rangePips .pip.selected) {
+    height: 0.75em;
+  }
+
+  :global(.rangePips.vertical .pip.selected) {
+    height: 1px;
+    width: 0.75em;
+  }
+
+  :global(.rangePips .pip.selected .pipVal) {
+    font-weight: bold;
+    top: 0.75em;
+  }
+
+  :global(.rangePips.vertical .pip.selected .pipVal) {
+    top: 0;
+    left: 0.75em;
+  }
+
+  :global(.rangePips.hoverable:not(.disabled) .pip:not(.selected):hover) {
+    transition: none;
+  }
+
+  :global(.rangePips.hoverable:not(.disabled) .pip:not(.selected):hover .pipVal) {
+    transition: none;
+    font-weight: bold;
+  }
+</style>
diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 50becec..9cc6b3e 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -1,5 +1,4 @@
 <script lang="ts">
-  import './RangeSlider.css';
   import { type SpringOpts, type Spring, spring } from 'svelte/motion';
   import { createEventDispatcher } from 'svelte';
   import {
@@ -681,3 +680,247 @@
   on:touchend={bodyTouchEnd}
   on:keydown={bodyKeyDown}
 />
+
+<style>
+  /**
+   * RangeSlider
+   */
+
+  :global(.rangeSlider) {
+    --slider: var(--range-slider, #d7dada);
+    --handle-inactive: var(--range-handle-inactive, #99a2a2);
+    --handle: var(--range-handle, #838de7);
+    --handle-focus: var(--range-handle-focus, #4a40d4);
+    --handle-border: var(--range-handle-border, var(--handle));
+    --range-inactive: var(--range-range-inactive, var(--handle-inactive));
+    --range: var(--range-range, var(--handle-focus));
+    --float-inactive: var(--range-float-inactive, var(--handle-inactive));
+    --float: var(--range-float, var(--handle-focus));
+    --float-text: var(--range-float-text, white);
+  }
+
+  :global(.rangeSlider) {
+    position: relative;
+    border-radius: 100px;
+    height: 0.5em;
+    margin: 1em;
+    transition: opacity 0.2s ease;
+    user-select: none;
+  }
+
+  :global(.rangeSlider *) {
+    user-select: none;
+  }
+
+  :global(.rangeSlider.pips) {
+    margin-bottom: 1.8em;
+  }
+
+  :global(.rangeSlider.pip-labels) {
+    margin-bottom: 2.8em;
+  }
+
+  :global(.rangeSlider.vertical) {
+    display: inline-block;
+    border-radius: 100px;
+    width: 0.5em;
+    min-height: 200px;
+  }
+
+  :global(.rangeSlider.vertical.pips) {
+    margin-right: 1.8em;
+    margin-bottom: 1em;
+  }
+
+  :global(.rangeSlider.vertical.pip-labels) {
+    margin-right: 2.8em;
+    margin-bottom: 1em;
+  }
+
+  :global(.rangeSlider .rangeHandle) {
+    position: absolute;
+    display: block;
+    height: 1.4em;
+    width: 1.4em;
+    top: 0.25em;
+    bottom: auto;
+    transform: translateY(-50%) translateX(-50%);
+    z-index: 2;
+  }
+
+  :global(.rangeSlider.reversed .rangeHandle) {
+    transform: translateY(-50%) translateX(50%);
+  }
+
+  :global(.rangeSlider.vertical .rangeHandle) {
+    left: 0.25em;
+    top: auto;
+    transform: translateY(50%) translateX(-50%);
+  }
+
+  :global(.rangeSlider.vertical.reversed .rangeHandle) {
+    transform: translateY(-50%) translateX(-50%);
+  }
+
+  :global(.rangeSlider .rangeNub),
+  :global(.rangeSlider .rangeHandle:before) {
+    position: absolute;
+    left: 0;
+    top: 0;
+    display: block;
+    border-radius: 10em;
+    height: 100%;
+    width: 100%;
+    transition: box-shadow 0.2s ease;
+  }
+
+  :global(.rangeSlider .rangeHandle:before) {
+    content: '';
+    left: 1px;
+    top: 1px;
+    bottom: 1px;
+    right: 1px;
+    height: auto;
+    width: auto;
+    box-shadow: 0 0 0 0px var(--handle-border);
+    opacity: 0;
+  }
+
+  :global(.rangeSlider.hoverable:not(.disabled) .rangeHandle:hover:before) {
+    box-shadow: 0 0 0 8px var(--handle-border);
+    opacity: 0.2;
+  }
+
+  :global(.rangeSlider.hoverable:not(.disabled) .rangeHandle.press:before),
+  :global(.rangeSlider.hoverable:not(.disabled) .rangeHandle.press:hover:before) {
+    box-shadow: 0 0 0 12px var(--handle-border);
+    opacity: 0.4;
+  }
+
+  :global(.rangeSlider.range:not(.min):not(.max) .rangeNub) {
+    border-radius: 10em 10em 10em 1.6em;
+  }
+
+  :global(.rangeSlider.range .rangeHandle:nth-of-type(1) .rangeNub) {
+    transform: rotate(-135deg);
+  }
+
+  :global(.rangeSlider.range .rangeHandle:nth-of-type(2) .rangeNub) {
+    transform: rotate(45deg);
+  }
+
+  :global(.rangeSlider.range.reversed .rangeHandle:nth-of-type(1) .rangeNub) {
+    transform: rotate(45deg);
+  }
+
+  :global(.rangeSlider.range.reversed .rangeHandle:nth-of-type(2) .rangeNub) {
+    transform: rotate(-135deg);
+  }
+
+  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(1) .rangeNub) {
+    transform: rotate(135deg);
+  }
+
+  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(2) .rangeNub) {
+    transform: rotate(-45deg);
+  }
+
+  :global(.rangeSlider.range.vertical.reversed .rangeHandle:nth-of-type(1) .rangeNub) {
+    transform: rotate(-45deg);
+  }
+
+  :global(.rangeSlider.range.vertical.reversed .rangeHandle:nth-of-type(2) .rangeNub) {
+    transform: rotate(135deg);
+  }
+
+  :global(.rangeSlider .rangeFloat) {
+    display: block;
+    position: absolute;
+    left: 50%;
+    top: -0.5em;
+    transform: translate(-50%, -100%);
+    font-size: 1em;
+    text-align: center;
+    opacity: 0;
+    pointer-events: none;
+    white-space: nowrap;
+    transition: all 0.2s ease;
+    font-size: 0.9em;
+    padding: 0.2em 0.4em;
+    border-radius: 0.2em;
+  }
+
+  :global(.rangeSlider .rangeHandle.active .rangeFloat),
+  :global(.rangeSlider.hoverable .rangeHandle:hover .rangeFloat) {
+    opacity: 1;
+    top: -0.2em;
+    transform: translate(-50%, -100%);
+  }
+
+  :global(.rangeSlider .rangeBar) {
+    position: absolute;
+    display: block;
+    transition: background 0.2s ease;
+    border-radius: 1em;
+    height: 0.5em;
+    top: 0;
+    user-select: none;
+    z-index: 1;
+  }
+
+  :global(.rangeSlider.vertical .rangeBar) {
+    width: 0.5em;
+    height: auto;
+  }
+
+  :global(.rangeSlider) {
+    background-color: #d7dada;
+    background-color: var(--slider);
+  }
+
+  :global(.rangeSlider .rangeBar) {
+    background-color: #99a2a2;
+    background-color: var(--range-inactive);
+  }
+
+  :global(.rangeSlider.focus .rangeBar) {
+    background-color: #838de7;
+    background-color: var(--range);
+  }
+
+  :global(.rangeSlider .rangeNub) {
+    background-color: #99a2a2;
+    background-color: var(--handle-inactive);
+  }
+
+  :global(.rangeSlider.focus .rangeNub) {
+    background-color: #838de7;
+    background-color: var(--handle);
+  }
+
+  :global(.rangeSlider .rangeHandle.active .rangeNub) {
+    background-color: #4a40d4;
+    background-color: var(--handle-focus);
+  }
+
+  :global(.rangeSlider .rangeFloat) {
+    color: white;
+    color: var(--float-text);
+    background-color: #99a2a2;
+    background-color: var(--float-inactive);
+  }
+
+  :global(.rangeSlider.focus .rangeFloat) {
+    background-color: #4a40d4;
+    background-color: var(--float);
+  }
+
+  :global(.rangeSlider.disabled) {
+    opacity: 0.5;
+  }
+
+  :global(.rangeSlider.disabled .rangeNub) {
+    background-color: #d7dada;
+    background-color: var(--slider);
+  }
+</style>

commit d749153e01de92f31e1ad8321017d53a345d2fb3
Author: simeydotme <simey.me@gmail.com>
Date:   Thu Feb 15 00:09:19 2024 +0800

    add vue/svelte5 testing suites

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index 65c06b6..6a3e3de 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -1,170 +1,170 @@
 <script lang="ts">
-	import {
-		coerceFloat,
-		valueAsPercent,
-		normalisedClient,
-		isInRange,
-		isSelected,
-		getValueFromIndex
-	} from '$lib/utils.js';
-	import type { Pip, Formatter, NormalisedClient } from '$lib/types.js';
+  import {
+    coerceFloat,
+    valueAsPercent,
+    normalisedClient,
+    isInRange,
+    isSelected,
+    getValueFromIndex
+  } from '$lib/utils.js';
+  import type { Pip, Formatter, NormalisedClient } from '$lib/types.js';
 
-	// range slider props
-	export let range: boolean | 'min' | 'max' = false;
-	export let min: number = 0;
-	export let max: number = 100;
-	export let step: number = 1;
-	export let value: number = (max + min) / 2;
-	export let values: number[] = [value];
-	export let vertical: boolean = false;
-	export let reversed: boolean = false;
-	export let hoverable: boolean = true;
-	export let disabled: boolean = false;
+  // range slider props
+  export let range: boolean | 'min' | 'max' = false;
+  export let min: number = 0;
+  export let max: number = 100;
+  export let step: number = 1;
+  export let value: number = (max + min) / 2;
+  export let values: number[] = [value];
+  export let vertical: boolean = false;
+  export let reversed: boolean = false;
+  export let hoverable: boolean = true;
+  export let disabled: boolean = false;
 
-	// range pips / values props
-	export let pipstep: number | undefined = undefined;
-	export let all: Pip = true;
-	export let first: Pip = undefined;
-	export let last: Pip = undefined;
-	export let rest: Pip = undefined;
+  // range pips / values props
+  export let pipstep: number | undefined = undefined;
+  export let all: Pip = true;
+  export let first: Pip = undefined;
+  export let last: Pip = undefined;
+  export let rest: Pip = undefined;
 
-	// formatting props
-	export let prefix: string = '';
-	export let suffix: string = '';
-	export let formatter: Formatter = (v, i, p) => v;
-	export let precision: number = 2;
+  // formatting props
+  export let prefix: string = '';
+  export let suffix: string = '';
+  export let formatter: Formatter = (v, i, p) => v;
+  export let precision: number = 2;
 
-	// stylistic props
-	export let focus: boolean;
-	export let orientationStart: string;
+  // stylistic props
+  export let focus: boolean;
+  export let orientationStart: string;
 
-	// methods
-	export let moveHandle: (index: number | null, value: number) => void;
+  // methods
+  export let moveHandle: (index: number | null, value: number) => void;
 
-	let clientStart: null | NormalisedClient = null;
+  let clientStart: null | NormalisedClient = null;
 
-	$: stepMax = vertical ? 50 : 100;
-	$: tooManyPips = (max - min) / step >= stepMax;
-	$: stepDivisor = vertical ? 10 : 20;
-	$: reducedSteps = (max - min) / stepDivisor;
-	$: pipStep = pipstep ?? (tooManyPips ? reducedSteps : 1);
-	$: pipCount = Math.floor((max - min) / (step * pipStep));
+  $: stepMax = vertical ? 50 : 100;
+  $: tooManyPips = (max - min) / step >= stepMax;
+  $: stepDivisor = vertical ? 10 : 20;
+  $: reducedSteps = (max - min) / stepDivisor;
+  $: pipStep = pipstep ?? (tooManyPips ? reducedSteps : 1);
+  $: pipCount = Math.floor((max - min) / (step * pipStep));
 
-	/**
-	 * function to run when the user clicks on a label
-	 * we store the original client position so we can check if the user has moved the mouse/finger
-	 * @param {event} event the event from browser
-	 **/
-	function labelDown(event: PointerEvent) {
-		clientStart = normalisedClient(event);
-	}
+  /**
+   * function to run when the user clicks on a label
+   * we store the original client position so we can check if the user has moved the mouse/finger
+   * @param {event} event the event from browser
+   **/
+  function labelDown(event: PointerEvent) {
+    clientStart = normalisedClient(event);
+  }
 
-	/**
-	 * function to run when the user releases the mouse/finger
-	 * we check if the user has moved the mouse/finger, if not we "click" the label
-	 * and move the handle it to the label position
-	 * @param {number} pipValue the value of the label
-	 * @param {event} e the event from browser
-	 */
-	function labelUp(pipValue: number, event: PointerEvent) {
-		const clientEnd = normalisedClient(event);
-		if (!disabled && clientStart) {
-			const distanceMoved = Math.sqrt(
-				Math.pow(clientStart.x - clientEnd.x, 2) + Math.pow(clientStart.y - clientEnd.y, 2)
-			);
-			if (distanceMoved <= 5) {
-				moveHandle(null, pipValue);
-			}
-			clientStart = null;
-		}
-	}
+  /**
+   * function to run when the user releases the mouse/finger
+   * we check if the user has moved the mouse/finger, if not we "click" the label
+   * and move the handle it to the label position
+   * @param {number} pipValue the value of the label
+   * @param {event} e the event from browser
+   */
+  function labelUp(pipValue: number, event: PointerEvent) {
+    const clientEnd = normalisedClient(event);
+    if (!disabled && clientStart) {
+      const distanceMoved = Math.sqrt(
+        Math.pow(clientStart.x - clientEnd.x, 2) + Math.pow(clientStart.y - clientEnd.y, 2)
+      );
+      if (distanceMoved <= 5) {
+        moveHandle(null, pipValue);
+      }
+      clientStart = null;
+    }
+  }
 </script>
 
 <div class="rangePips" class:disabled class:hoverable class:vertical class:reversed class:focus>
-	{#if (all && first !== false) || first}
-		<span
-			class="pip first"
-			class:selected={isSelected(min, values, precision)}
-			class:in-range={isInRange(min, values, range)}
-			style="{orientationStart}: 0%;"
-			on:pointerdown={(e) => {
-				labelDown(e);
-			}}
-			on:pointerup={(e) => {
-				labelUp(min, e);
-			}}
-		>
-			{#if all === 'label' || first === 'label'}
-				<span class="pipVal">
-					{#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
-						coerceFloat(min),
-						0,
-						0
-					)}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
-				</span>
-			{/if}
-		</span>
-	{/if}
+  {#if (all && first !== false) || first}
+    <span
+      class="pip first"
+      class:selected={isSelected(min, values, precision)}
+      class:in-range={isInRange(min, values, range)}
+      style="{orientationStart}: 0%;"
+      on:pointerdown={(e) => {
+        labelDown(e);
+      }}
+      on:pointerup={(e) => {
+        labelUp(min, e);
+      }}
+    >
+      {#if all === 'label' || first === 'label'}
+        <span class="pipVal">
+          {#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
+            coerceFloat(min),
+            0,
+            0
+          )}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+        </span>
+      {/if}
+    </span>
+  {/if}
 
-	{#if (all && rest !== false) || rest}
-		{#each Array(pipCount + 1) as _, i}
-			{#if getValueFromIndex(i, min, max, pipStep, step) !== min && getValueFromIndex(i, min, max, pipStep, step) !== max}
-				<span
-					class="pip"
-					class:selected={isSelected(
-						getValueFromIndex(i, min, max, pipStep, step),
-						values,
-						precision
-					)}
-					class:in-range={isInRange(getValueFromIndex(i, min, max, pipStep, step), values, range)}
-					style="{orientationStart}: {valueAsPercent(
-						getValueFromIndex(i, min, max, pipStep, step),
-						min,
-						max
-					)}%;"
-					on:pointerdown={(e) => {
-						labelDown(e);
-					}}
-					on:pointerup={(e) => {
-						labelUp(getValueFromIndex(i, min, max, pipStep, step), e);
-					}}
-				>
-					{#if all === 'label' || rest === 'label'}
-						<span class="pipVal">
-							{#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
-								getValueFromIndex(i, min, max, pipStep, step),
-								i,
-								valueAsPercent(getValueFromIndex(i, min, max, pipStep, step), min, max, precision)
-							)}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
-						</span>
-					{/if}
-				</span>
-			{/if}
-		{/each}
-	{/if}
+  {#if (all && rest !== false) || rest}
+    {#each Array(pipCount + 1) as _, i}
+      {#if getValueFromIndex(i, min, max, pipStep, step) !== min && getValueFromIndex(i, min, max, pipStep, step) !== max}
+        <span
+          class="pip"
+          class:selected={isSelected(
+            getValueFromIndex(i, min, max, pipStep, step),
+            values,
+            precision
+          )}
+          class:in-range={isInRange(getValueFromIndex(i, min, max, pipStep, step), values, range)}
+          style="{orientationStart}: {valueAsPercent(
+            getValueFromIndex(i, min, max, pipStep, step),
+            min,
+            max
+          )}%;"
+          on:pointerdown={(e) => {
+            labelDown(e);
+          }}
+          on:pointerup={(e) => {
+            labelUp(getValueFromIndex(i, min, max, pipStep, step), e);
+          }}
+        >
+          {#if all === 'label' || rest === 'label'}
+            <span class="pipVal">
+              {#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
+                getValueFromIndex(i, min, max, pipStep, step),
+                i,
+                valueAsPercent(getValueFromIndex(i, min, max, pipStep, step), min, max, precision)
+              )}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+            </span>
+          {/if}
+        </span>
+      {/if}
+    {/each}
+  {/if}
 
-	{#if (all && last !== false) || last}
-		<span
-			class="pip last"
-			class:selected={isSelected(max, values, precision)}
-			class:in-range={isInRange(max, values, range)}
-			style="{orientationStart}: 100%;"
-			on:pointerdown={(e) => {
-				labelDown(e);
-			}}
-			on:pointerup={(e) => {
-				labelUp(max, e);
-			}}
-		>
-			{#if all === 'label' || last === 'label'}
-				<span class="pipVal">
-					{#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
-						coerceFloat(max),
-						pipCount,
-						100
-					)}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
-				</span>
-			{/if}
-		</span>
-	{/if}
+  {#if (all && last !== false) || last}
+    <span
+      class="pip last"
+      class:selected={isSelected(max, values, precision)}
+      class:in-range={isInRange(max, values, range)}
+      style="{orientationStart}: 100%;"
+      on:pointerdown={(e) => {
+        labelDown(e);
+      }}
+      on:pointerup={(e) => {
+        labelUp(max, e);
+      }}
+    >
+      {#if all === 'label' || last === 'label'}
+        <span class="pipVal">
+          {#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
+            coerceFloat(max),
+            pipCount,
+            100
+          )}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+        </span>
+      {/if}
+    </span>
+  {/if}
 </div>
diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 9fe53ba..50becec 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -1,683 +1,683 @@
 <script lang="ts">
-	import './RangeSlider.css';
-	import { type SpringOpts, type Spring, spring } from 'svelte/motion';
-	import { createEventDispatcher } from 'svelte';
-	import {
-		coerceFloat,
-		valueAsPercent,
-		clampValue,
-		alignValueToStep,
-		pureText,
-		normalisedClient,
-		elementIndex
-	} from '$lib/utils.js';
-	import type { Pip, Formatter, NormalisedClient } from '$lib/types.js';
-
-	import RangePips from './RangePips.svelte';
-
-	// dom references
-	export let slider: HTMLDivElement | undefined = undefined;
-
-	// range slider props
-	export let range: boolean | 'min' | 'max' = false;
-	export let pushy: boolean = false;
-	export let min: number = 0;
-	export let max: number = 100;
-	export let step: number = 1;
-	export let values: number[] = [(max + min) / 2];
-	export let value: number = values[0];
-	export let vertical: boolean = false;
-	export let float: boolean = false;
-	export let reversed: boolean = false;
-	export let hoverable: boolean = true;
-	export let disabled: boolean = false;
-
-	// range pips / values props
-	export let pips: boolean = false;
-	export let pipstep: number | undefined = undefined;
-	export let all: Pip = true;
-	export let first: Pip = undefined;
-	export let last: Pip = undefined;
-	export let rest: Pip = undefined;
-
-	// formatting props
-	export let id: string | undefined = undefined;
-	export let prefix: string = '';
-	export let suffix: string = '';
-	export let formatter: Formatter = (v, i, p) => v;
-	export let handleFormatter = formatter;
-	export let ariaLabels: string[] = [];
-
-	// stylistic props
-	export let precision: number = 2;
-	export let springValues: SpringOpts = { stiffness: 0.15, damping: 0.4 };
-
-	// prepare dispatched events
-	const dispatch = createEventDispatcher();
-
-	// state management
-	let valueLength = 0;
-	let focus = false;
-	let handleActivated = false;
-	let handlePressed = false;
-	let keyboardActive = false;
-	let activeHandle = values.length - 1;
-	let startValue: number;
-	let previousValue: number;
-
-	// copy the initial values in to a spring function which
-	// will update every time the values array is modified
-	let springPositions: Spring<number[]>;
-
-	// check that "values" is an array, or set it as array
-	const updateValues = () => {
-		checkValuesIsArray();
-		// sync values with value
-		if (values[0] !== value) {
-			values[0] = value;
-		}
-	};
-
-	// check that "value" is a number, or set it as the average
-	const updateValue = () => {
-		checkValueIsNumber();
-		// sync value with values
-		if (value !== values[0]) {
-			value = values[0];
-		}
-	};
-
-	const checkValueIsNumber = () => {
-		if (typeof value !== 'number') {
-			value = (max + min) / 2;
-			console.error("'value' prop should be a Number");
-		}
-	};
-
-	const checkValuesIsArray = () => {
-		if (!Array.isArray(values)) {
-			values = [value];
-			console.error("'values' prop should be an Array");
-		}
-	};
-
-	const checkAriaLabels = () => {
-		if (values.length > 1 && !Array.isArray(ariaLabels)) {
-			console.warn(`'ariaLabels' prop should be an Array`);
-		}
-	};
-
-	// fixup the value/values at render
-	checkValueIsNumber();
-	checkValuesIsArray();
-
-	// keep value and values in sync with each other
-	$: value, updateValues();
-	$: values, updateValue();
-	$: ariaLabels, checkAriaLabels();
-
-	$: {
-		// trim the range so it remains as a min/max (only 2 handles)
-		// and also align the handles to the steps
-		const trimmedAlignedValues = trimRange(
-			values.map((v) => alignValueToStep(v, min, max, step, precision))
-		);
-		if (
-			!(values.length === trimmedAlignedValues.length) ||
-			!values.every(
-				(element, index) => coerceFloat(element, precision) === trimmedAlignedValues[index]
-			)
-		) {
-			values = trimmedAlignedValues;
-		}
-
-		// check if the valueLength (length of values[]) has changed,
-		// because if so we need to re-seed the spring function with the
-		// new values array.
-		if (valueLength !== values.length) {
-			// set the initial spring values when the slider initialises,
-			// or when values array length has changed
-			springPositions = spring(
-				values.map((v) => valueAsPercent(v, min, max)),
-				springValues
-			);
-		} else {
-			// update the value of the spring function for animated handles
-			// whenever the values has updated
-			springPositions.set(values.map((v) => valueAsPercent(v, min, max)));
-		}
-		// set the valueLength for the next check
-		valueLength = values.length;
-	}
-
-	/**
-	 * the orientation of the handles/pips based on the
-	 * input values of vertical and reversed
-	 **/
-	$: orientationStart = vertical ? (reversed ? 'top' : 'bottom') : reversed ? 'right' : 'left';
-	$: orientationEnd = vertical ? (reversed ? 'bottom' : 'top') : reversed ? 'left' : 'right';
-
-	/**
-	 * check if an element is a handle on the slider
-	 * @param {object} el dom object reference we want to check
-	 * @returns {boolean}
-	 **/
-	function targetIsHandle(el: Element) {
-		if (!slider) return false;
-		const handles = slider.querySelectorAll('.handle');
-		const isHandle = Array.prototype.includes.call(handles, el);
-		const isChild = Array.prototype.some.call(handles, (e) => e.contains(el));
-		return isHandle || isChild;
-	}
-
-	/**
-	 * trim the values array based on whether the property
-	 * for 'range' is 'min', 'max', or truthy. This is because we
-	 * do not want more than one handle for a min/max range, and we do
-	 * not want more than two handles for a true range.
-	 * @param {array} values the input values for the rangeSlider
-	 * @return {array} the range array for creating a rangeSlider
-	 **/
-	function trimRange(values: number[]) {
-		if (range === 'min' || range === 'max') {
-			return values.slice(0, 1);
-		} else if (range) {
-			return values.slice(0, 2);
-		} else {
-			return values;
-		}
-	}
-
-	/**
-	 * helper to return closest handle to user interaction
-	 * @param {object} clientPos the client {x,y} positions to check against
-	 * @return {number} the index of the closest handle to clientPos
-	 **/
-	function getClosestHandle(clientPos: NormalisedClient) {
-		if (!slider) return 0;
-		// first make sure we have the latest dimensions
-		// of the slider, as it may have changed size
-		const dims = slider.getBoundingClientRect();
-		// calculate the interaction position, percent and value
-		let handlePos = 0;
-		let handlePercent = 0;
-		let handleVal = 0;
-		if (vertical) {
-			handlePos = clientPos.y - dims.top;
-			handlePercent = (handlePos / dims.height) * 100;
-			handlePercent = reversed ? handlePercent : 100 - handlePercent;
-		} else {
-			handlePos = clientPos.x - dims.left;
-			handlePercent = (handlePos / dims.width) * 100;
-			handlePercent = reversed ? 100 - handlePercent : handlePercent;
-		}
-		handleVal = ((max - min) / 100) * handlePercent + min;
-
-		let closest;
-
-		// if we have a range, and the handles are at the same
-		// position, we want a simple check if the interaction
-		// value is greater than return the second handle
-		if (range === true && values[0] === values[1]) {
-			if (handleVal > values[1]) {
-				return 1;
-			} else {
-				return 0;
-			}
-			// if there are multiple handles, and not a range, then
-			// we sort the handles values, and return the first one closest
-			// to the interaction value
-		} else {
-			closest = values.indexOf(
-				[...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]
-			);
-		}
-		return closest;
-	}
-
-	/**
-	 * take the interaction position on the slider, convert
-	 * it to a value on the range, and then send that value
-	 * through to the moveHandle() method to set the active
-	 * handle's position
-	 * @param {object} clientPos the client {x,y} of the interaction
-	 **/
-	function handleInteract(clientPos: NormalisedClient) {
-		if (!slider) return;
-		// first make sure we have the latest dimensions
-		// of the slider, as it may have changed size
-		const dims = slider.getBoundingClientRect();
-		// calculate the interaction position, percent and value
-		let handlePos = 0;
-		let handlePercent = 0;
-		let handleVal = 0;
-		if (vertical) {
-			handlePos = clientPos.y - dims.top;
-			handlePercent = (handlePos / dims.height) * 100;
-			handlePercent = reversed ? handlePercent : 100 - handlePercent;
-		} else {
-			handlePos = clientPos.x - dims.left;
-			handlePercent = (handlePos / dims.width) * 100;
-			handlePercent = reversed ? 100 - handlePercent : handlePercent;
-		}
-		handleVal = ((max - min) / 100) * handlePercent + min;
-		// move handle to the value
-		moveHandle(activeHandle, handleVal);
-	}
-
-	/**
-	 * move a handle to a specific value, respecting the clamp/align rules
-	 * @param {number} index the index of the handle we want to move
-	 * @param {number} value the value to move the handle to
-	 * @return {number} the value that was moved to (after alignment/clamping)
-	 **/
-	function moveHandle(index: number | null, value: number) {
-		// align & clamp the value so we're not doing extra
-		// calculation on an out-of-range value down below
-		value = alignValueToStep(value, min, max, step, precision);
-		// use the active handle if handle index is not provided
-		if (index === null) {
-			index = activeHandle;
-		}
-		// if this is a range slider perform special checks
-		if (range) {
-			// restrict the handles of a range-slider from
-			// going past one-another unless "pushy" is true
-			if (index === 0 && value > values[1]) {
-				if (pushy) {
-					values[1] = value;
-				} else {
-					value = values[1];
-				}
-			} else if (index === 1 && value < values[0]) {
-				if (pushy) {
-					values[0] = value;
-				} else {
-					value = values[0];
-				}
-			}
-		}
-
-		// if the value has changed, update it
-		if (values[index] !== value) {
-			values[index] = value;
-		}
-
-		// fire the change event when the handle moves,
-		// and store the previous value for the next time
-		if (previousValue !== value) {
-			eChange();
-			previousValue = value;
-		}
-		return value;
-	}
-
-	/**
-	 * helper to find the beginning range value for use with css style
-	 * @param {array} values the input values for the rangeSlider
-	 * @return {number} the beginning of the range
-	 **/
-	function rangeStart(values: number[]) {
-		if (range === 'min') {
-			return 0;
-		} else {
-			return values[0];
-		}
-	}
-
-	/**
-	 * helper to find the ending range value for use with css style
-	 * @param {array} values the input values for the rangeSlider
-	 * @return {number} the end of the range
-	 **/
-	function rangeEnd(values: number[]) {
-		if (range === 'max') {
-			return 0;
-		} else if (range === 'min') {
-			return 100 - values[0];
-		} else {
-			return 100 - values[1];
-		}
-	}
-
-	/**
-	 * when the user has unfocussed (blurred) from the
-	 * slider, deactivate all handles
-	 * @param {FocusEvent} event the event from browser
-	 **/
-	function sliderBlurHandle(event: FocusEvent) {
-		const target = event.target as HTMLSpanElement;
-		if (keyboardActive) {
-			focus = false;
-			handleActivated = false;
-			handlePressed = false;
-		}
-	}
-
-	/**
-	 * when the user focusses the handle of a slider
-	 * set it to be active
-	 * @param {FocusEvent} event the event from browser
-	 **/
-	function sliderFocusHandle(event: FocusEvent) {
-		const target = event.target as HTMLSpanElement;
-		if (!disabled) {
-			activeHandle = elementIndex(target);
-			focus = true;
-		}
-	}
-
-	/**
-	 * handle the keyboard accessible features by checking the
-	 * input type, and modfier key then moving handle by appropriate amount
-	 * @param {KeyboardEvent} event the event from browser
-	 **/
-	function sliderKeydown(event: KeyboardEvent) {
-		if (!disabled) {
-			let prevent = false;
-			const handle = elementIndex(event.target as HTMLSpanElement);
-			let jump = step;
-			if (event.ctrlKey || event.metaKey) {
-				jump = clampValue(
-					(max - min) / step / 100,
-					coerceFloat(jump, precision),
-					coerceFloat((max - min) / 100, precision)
-				);
-				// ~ 1%
-			} else if (event.shiftKey) {
-				// ~ 10%
-				jump = clampValue(
-					(max - min) / step / 10,
-					coerceFloat(jump, precision),
-					coerceFloat((max - min) / 10, precision)
-				);
-			}
-
-			switch (event.key) {
-				case 'PageDown':
-					jump *= 10;
-				case 'ArrowRight':
-				case 'ArrowUp':
-					moveHandle(handle, values[handle] + coerceFloat(jump, precision));
-					prevent = true;
-					break;
-				case 'PageUp':
-					jump *= 10;
-				case 'ArrowLeft':
-				case 'ArrowDown':
-					moveHandle(handle, values[handle] - coerceFloat(jump, precision));
-					prevent = true;
-					break;
-				case 'Home':
-					moveHandle(handle, min);
-					prevent = true;
-					break;
-				case 'End':
-					moveHandle(handle, max);
-					prevent = true;
-					break;
-			}
-			if (prevent) {
-				event.preventDefault();
-				event.stopPropagation();
-			}
-		}
-	}
-
-	/**
-	 * function to run when the user touches
-	 * down on the slider element anywhere
-	 * @param {MouseEvent | TouchEvent} event the event from browser
-	 **/
-	function sliderInteractStart(event: MouseEvent | TouchEvent) {
-		if (!disabled) {
-			const target = event.target as Element;
-			const clientPos = normalisedClient(event);
-			// set the closest handle as active
-			focus = true;
-			handleActivated = true;
-			handlePressed = true;
-			activeHandle = getClosestHandle(clientPos);
-
-			// fire the start event
-			startValue = previousValue = alignValueToStep(
-				values[activeHandle],
-				min,
-				max,
-				step,
-				precision
-			);
-			eStart();
-
-			// for touch devices we want the handle to instantly
-			// move to the position touched for more responsive feeling
-			if (event.type === 'touchstart' && !target.matches('.pipVal')) {
-				handleInteract(clientPos);
-			}
-		}
-	}
-
-	/**
-	 * function to run when the user stops touching
-	 * down on the slider element anywhere
-	 * @param {event} e the event from browser
-	 **/
-	function sliderInteractEnd(event: MouseEvent | TouchEvent) {
-		// fire the stop event for touch devices
-		if (event.type === 'touchend') {
-			eStop();
-		}
-		handlePressed = false;
-	}
-
-	/**
-	 * unfocus the slider if the user clicked off of
-	 * it, somewhere else on the screen
-	 * @param {MouseEvent | TouchEvent} event the event from browser
-	 **/
-	function bodyInteractStart(event: MouseEvent | TouchEvent) {
-		const target = event.target as Element;
-		keyboardActive = false;
-		if (slider && focus && target !== slider && !slider.contains(target)) {
-			focus = false;
-		}
-	}
-
-	/**
-	 * send the clientX through to handle the interaction
-	 * whenever the user moves acros screen while active
-	 * @param {MouseEvent | TouchEvent} event the event from browser
-	 **/
-	function bodyInteract(event: MouseEvent | TouchEvent) {
-		if (!disabled) {
-			if (handleActivated) {
-				handleInteract(normalisedClient(event));
-			}
-		}
-	}
-
-	/**
-	 * if user triggers mouseup on the body while
-	 * a handle is active (without moving) then we
-	 * trigger an interact event there
-	 * @param {event} event the event from browser
-	 **/
-	function bodyMouseUp(event: MouseEvent) {
-		if (!disabled) {
-			const target = event.target as Element;
-			// this only works if a handle is active, which can
-			// only happen if there was sliderInteractStart triggered
-			// on the slider, already
-			if (handleActivated) {
-				if (slider && (target === slider || slider.contains(target))) {
-					focus = true;
-					// don't trigger interact if the target is a handle (no need) or
-					// if the target is a label (we want to move to that value from rangePips)
-					if (!targetIsHandle(target) && !target.matches('.pipVal')) {
-						handleInteract(normalisedClient(event));
-					}
-				}
-				// fire the stop event for mouse device
-				// when the body is triggered with an active handle
-				eStop();
-			}
-		}
-		handleActivated = false;
-		handlePressed = false;
-	}
-
-	/**
-	 * if user triggers touchend on the body then we
-	 * defocus the slider completely
-	 * @param {event} event the event from browser
-	 **/
-	function bodyTouchEnd(event: TouchEvent) {
-		handleActivated = false;
-		handlePressed = false;
-	}
-
-	function bodyKeyDown(event: KeyboardEvent) {
-		const target = event.target as Element;
-		if (!disabled && slider) {
-			if (target === slider || slider.contains(target)) {
-				keyboardActive = true;
-			}
-		}
-	}
-
-	function eStart() {
-		!disabled &&
-			dispatch('start', {
-				activeHandle,
-				value: startValue,
-				values: values.map((v) => alignValueToStep(v, min, max, step, precision))
-			});
-	}
-
-	function eStop() {
-		!disabled &&
-			dispatch('stop', {
-				activeHandle,
-				startValue: startValue,
-				value: values[activeHandle],
-				values: values.map((v) => alignValueToStep(v, min, max, step, precision))
-			});
-	}
-
-	function eChange() {
-		!disabled &&
-			dispatch('change', {
-				activeHandle,
-				startValue: startValue,
-				previousValue: typeof previousValue === 'undefined' ? startValue : previousValue,
-				value: values[activeHandle],
-				values: values.map((v) => alignValueToStep(v, min, max, step, precision))
-			});
-	}
-
-	function ariaLabelFormatter(value: number, index: number) {
-		const percent = valueAsPercent(value, min, max, precision);
-		const formattedValue = handleFormatter(value, index, percent);
-		const textLabel = pureText(String(formattedValue));
-		return `${prefix}${textLabel}${suffix}`;
-	}
+  import './RangeSlider.css';
+  import { type SpringOpts, type Spring, spring } from 'svelte/motion';
+  import { createEventDispatcher } from 'svelte';
+  import {
+    coerceFloat,
+    valueAsPercent,
+    clampValue,
+    alignValueToStep,
+    pureText,
+    normalisedClient,
+    elementIndex
+  } from '$lib/utils.js';
+  import type { Pip, Formatter, NormalisedClient } from '$lib/types.js';
+
+  import RangePips from './RangePips.svelte';
+
+  // dom references
+  export let slider: HTMLDivElement | undefined = undefined;
+
+  // range slider props
+  export let range: boolean | 'min' | 'max' = false;
+  export let pushy: boolean = false;
+  export let min: number = 0;
+  export let max: number = 100;
+  export let step: number = 1;
+  export let values: number[] = [(max + min) / 2];
+  export let value: number = values[0];
+  export let vertical: boolean = false;
+  export let float: boolean = false;
+  export let reversed: boolean = false;
+  export let hoverable: boolean = true;
+  export let disabled: boolean = false;
+
+  // range pips / values props
+  export let pips: boolean = false;
+  export let pipstep: number | undefined = undefined;
+  export let all: Pip = true;
+  export let first: Pip = undefined;
+  export let last: Pip = undefined;
+  export let rest: Pip = undefined;
+
+  // formatting props
+  export let id: string | undefined = undefined;
+  export let prefix: string = '';
+  export let suffix: string = '';
+  export let formatter: Formatter = (v, i, p) => v;
+  export let handleFormatter = formatter;
+  export let ariaLabels: string[] = [];
+
+  // stylistic props
+  export let precision: number = 2;
+  export let springValues: SpringOpts = { stiffness: 0.15, damping: 0.4 };
+
+  // prepare dispatched events
+  const dispatch = createEventDispatcher();
+
+  // state management
+  let valueLength = 0;
+  let focus = false;
+  let handleActivated = false;
+  let handlePressed = false;
+  let keyboardActive = false;
+  let activeHandle = values.length - 1;
+  let startValue: number;
+  let previousValue: number;
+
+  // copy the initial values in to a spring function which
+  // will update every time the values array is modified
+  let springPositions: Spring<number[]>;
+
+  // check that "values" is an array, or set it as array
+  const updateValues = () => {
+    checkValuesIsArray();
+    // sync values with value
+    if (values[0] !== value) {
+      values[0] = value;
+    }
+  };
+
+  // check that "value" is a number, or set it as the average
+  const updateValue = () => {
+    checkValueIsNumber();
+    // sync value with values
+    if (value !== values[0]) {
+      value = values[0];
+    }
+  };
+
+  const checkValueIsNumber = () => {
+    if (typeof value !== 'number') {
+      value = (max + min) / 2;
+      console.error("'value' prop should be a Number");
+    }
+  };
+
+  const checkValuesIsArray = () => {
+    if (!Array.isArray(values)) {
+      values = [value];
+      console.error("'values' prop should be an Array");
+    }
+  };
+
+  const checkAriaLabels = () => {
+    if (values.length > 1 && !Array.isArray(ariaLabels)) {
+      console.warn(`'ariaLabels' prop should be an Array`);
+    }
+  };
+
+  // fixup the value/values at render
+  checkValueIsNumber();
+  checkValuesIsArray();
+
+  // keep value and values in sync with each other
+  $: value, updateValues();
+  $: values, updateValue();
+  $: ariaLabels, checkAriaLabels();
+
+  $: {
+    // trim the range so it remains as a min/max (only 2 handles)
+    // and also align the handles to the steps
+    const trimmedAlignedValues = trimRange(
+      values.map((v) => alignValueToStep(v, min, max, step, precision))
+    );
+    if (
+      !(values.length === trimmedAlignedValues.length) ||
+      !values.every(
+        (element, index) => coerceFloat(element, precision) === trimmedAlignedValues[index]
+      )
+    ) {
+      values = trimmedAlignedValues;
+    }
+
+    // check if the valueLength (length of values[]) has changed,
+    // because if so we need to re-seed the spring function with the
+    // new values array.
+    if (valueLength !== values.length) {
+      // set the initial spring values when the slider initialises,
+      // or when values array length has changed
+      springPositions = spring(
+        values.map((v) => valueAsPercent(v, min, max)),
+        springValues
+      );
+    } else {
+      // update the value of the spring function for animated handles
+      // whenever the values has updated
+      springPositions.set(values.map((v) => valueAsPercent(v, min, max)));
+    }
+    // set the valueLength for the next check
+    valueLength = values.length;
+  }
+
+  /**
+   * the orientation of the handles/pips based on the
+   * input values of vertical and reversed
+   **/
+  $: orientationStart = vertical ? (reversed ? 'top' : 'bottom') : reversed ? 'right' : 'left';
+  $: orientationEnd = vertical ? (reversed ? 'bottom' : 'top') : reversed ? 'left' : 'right';
+
+  /**
+   * check if an element is a handle on the slider
+   * @param {object} el dom object reference we want to check
+   * @returns {boolean}
+   **/
+  function targetIsHandle(el: Element) {
+    if (!slider) return false;
+    const handles = slider.querySelectorAll('.handle');
+    const isHandle = Array.prototype.includes.call(handles, el);
+    const isChild = Array.prototype.some.call(handles, (e) => e.contains(el));
+    return isHandle || isChild;
+  }
+
+  /**
+   * trim the values array based on whether the property
+   * for 'range' is 'min', 'max', or truthy. This is because we
+   * do not want more than one handle for a min/max range, and we do
+   * not want more than two handles for a true range.
+   * @param {array} values the input values for the rangeSlider
+   * @return {array} the range array for creating a rangeSlider
+   **/
+  function trimRange(values: number[]) {
+    if (range === 'min' || range === 'max') {
+      return values.slice(0, 1);
+    } else if (range) {
+      return values.slice(0, 2);
+    } else {
+      return values;
+    }
+  }
+
+  /**
+   * helper to return closest handle to user interaction
+   * @param {object} clientPos the client {x,y} positions to check against
+   * @return {number} the index of the closest handle to clientPos
+   **/
+  function getClosestHandle(clientPos: NormalisedClient) {
+    if (!slider) return 0;
+    // first make sure we have the latest dimensions
+    // of the slider, as it may have changed size
+    const dims = slider.getBoundingClientRect();
+    // calculate the interaction position, percent and value
+    let handlePos = 0;
+    let handlePercent = 0;
+    let handleVal = 0;
+    if (vertical) {
+      handlePos = clientPos.y - dims.top;
+      handlePercent = (handlePos / dims.height) * 100;
+      handlePercent = reversed ? handlePercent : 100 - handlePercent;
+    } else {
+      handlePos = clientPos.x - dims.left;
+      handlePercent = (handlePos / dims.width) * 100;
+      handlePercent = reversed ? 100 - handlePercent : handlePercent;
+    }
+    handleVal = ((max - min) / 100) * handlePercent + min;
+
+    let closest;
+
+    // if we have a range, and the handles are at the same
+    // position, we want a simple check if the interaction
+    // value is greater than return the second handle
+    if (range === true && values[0] === values[1]) {
+      if (handleVal > values[1]) {
+        return 1;
+      } else {
+        return 0;
+      }
+      // if there are multiple handles, and not a range, then
+      // we sort the handles values, and return the first one closest
+      // to the interaction value
+    } else {
+      closest = values.indexOf(
+        [...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]
+      );
+    }
+    return closest;
+  }
+
+  /**
+   * take the interaction position on the slider, convert
+   * it to a value on the range, and then send that value
+   * through to the moveHandle() method to set the active
+   * handle's position
+   * @param {object} clientPos the client {x,y} of the interaction
+   **/
+  function handleInteract(clientPos: NormalisedClient) {
+    if (!slider) return;
+    // first make sure we have the latest dimensions
+    // of the slider, as it may have changed size
+    const dims = slider.getBoundingClientRect();
+    // calculate the interaction position, percent and value
+    let handlePos = 0;
+    let handlePercent = 0;
+    let handleVal = 0;
+    if (vertical) {
+      handlePos = clientPos.y - dims.top;
+      handlePercent = (handlePos / dims.height) * 100;
+      handlePercent = reversed ? handlePercent : 100 - handlePercent;
+    } else {
+      handlePos = clientPos.x - dims.left;
+      handlePercent = (handlePos / dims.width) * 100;
+      handlePercent = reversed ? 100 - handlePercent : handlePercent;
+    }
+    handleVal = ((max - min) / 100) * handlePercent + min;
+    // move handle to the value
+    moveHandle(activeHandle, handleVal);
+  }
+
+  /**
+   * move a handle to a specific value, respecting the clamp/align rules
+   * @param {number} index the index of the handle we want to move
+   * @param {number} value the value to move the handle to
+   * @return {number} the value that was moved to (after alignment/clamping)
+   **/
+  function moveHandle(index: number | null, value: number) {
+    // align & clamp the value so we're not doing extra
+    // calculation on an out-of-range value down below
+    value = alignValueToStep(value, min, max, step, precision);
+    // use the active handle if handle index is not provided
+    if (index === null) {
+      index = activeHandle;
+    }
+    // if this is a range slider perform special checks
+    if (range) {
+      // restrict the handles of a range-slider from
+      // going past one-another unless "pushy" is true
+      if (index === 0 && value > values[1]) {
+        if (pushy) {
+          values[1] = value;
+        } else {
+          value = values[1];
+        }
+      } else if (index === 1 && value < values[0]) {
+        if (pushy) {
+          values[0] = value;
+        } else {
+          value = values[0];
+        }
+      }
+    }
+
+    // if the value has changed, update it
+    if (values[index] !== value) {
+      values[index] = value;
+    }
+
+    // fire the change event when the handle moves,
+    // and store the previous value for the next time
+    if (previousValue !== value) {
+      eChange();
+      previousValue = value;
+    }
+    return value;
+  }
+
+  /**
+   * helper to find the beginning range value for use with css style
+   * @param {array} values the input values for the rangeSlider
+   * @return {number} the beginning of the range
+   **/
+  function rangeStart(values: number[]) {
+    if (range === 'min') {
+      return 0;
+    } else {
+      return values[0];
+    }
+  }
+
+  /**
+   * helper to find the ending range value for use with css style
+   * @param {array} values the input values for the rangeSlider
+   * @return {number} the end of the range
+   **/
+  function rangeEnd(values: number[]) {
+    if (range === 'max') {
+      return 0;
+    } else if (range === 'min') {
+      return 100 - values[0];
+    } else {
+      return 100 - values[1];
+    }
+  }
+
+  /**
+   * when the user has unfocussed (blurred) from the
+   * slider, deactivate all handles
+   * @param {FocusEvent} event the event from browser
+   **/
+  function sliderBlurHandle(event: FocusEvent) {
+    const target = event.target as HTMLSpanElement;
+    if (keyboardActive) {
+      focus = false;
+      handleActivated = false;
+      handlePressed = false;
+    }
+  }
+
+  /**
+   * when the user focusses the handle of a slider
+   * set it to be active
+   * @param {FocusEvent} event the event from browser
+   **/
+  function sliderFocusHandle(event: FocusEvent) {
+    const target = event.target as HTMLSpanElement;
+    if (!disabled) {
+      activeHandle = elementIndex(target);
+      focus = true;
+    }
+  }
+
+  /**
+   * handle the keyboard accessible features by checking the
+   * input type, and modfier key then moving handle by appropriate amount
+   * @param {KeyboardEvent} event the event from browser
+   **/
+  function sliderKeydown(event: KeyboardEvent) {
+    if (!disabled) {
+      let prevent = false;
+      const handle = elementIndex(event.target as HTMLSpanElement);
+      let jump = step;
+      if (event.ctrlKey || event.metaKey) {
+        jump = clampValue(
+          (max - min) / step / 100,
+          coerceFloat(jump, precision),
+          coerceFloat((max - min) / 100, precision)
+        );
+        // ~ 1%
+      } else if (event.shiftKey) {
+        // ~ 10%
+        jump = clampValue(
+          (max - min) / step / 10,
+          coerceFloat(jump, precision),
+          coerceFloat((max - min) / 10, precision)
+        );
+      }
+
+      switch (event.key) {
+        case 'PageDown':
+          jump *= 10;
+        case 'ArrowRight':
+        case 'ArrowUp':
+          moveHandle(handle, values[handle] + coerceFloat(jump, precision));
+          prevent = true;
+          break;
+        case 'PageUp':
+          jump *= 10;
+        case 'ArrowLeft':
+        case 'ArrowDown':
+          moveHandle(handle, values[handle] - coerceFloat(jump, precision));
+          prevent = true;
+          break;
+        case 'Home':
+          moveHandle(handle, min);
+          prevent = true;
+          break;
+        case 'End':
+          moveHandle(handle, max);
+          prevent = true;
+          break;
+      }
+      if (prevent) {
+        event.preventDefault();
+        event.stopPropagation();
+      }
+    }
+  }
+
+  /**
+   * function to run when the user touches
+   * down on the slider element anywhere
+   * @param {MouseEvent | TouchEvent} event the event from browser
+   **/
+  function sliderInteractStart(event: MouseEvent | TouchEvent) {
+    if (!disabled) {
+      const target = event.target as Element;
+      const clientPos = normalisedClient(event);
+      // set the closest handle as active
+      focus = true;
+      handleActivated = true;
+      handlePressed = true;
+      activeHandle = getClosestHandle(clientPos);
+
+      // fire the start event
+      startValue = previousValue = alignValueToStep(
+        values[activeHandle],
+        min,
+        max,
+        step,
+        precision
+      );
+      eStart();
+
+      // for touch devices we want the handle to instantly
+      // move to the position touched for more responsive feeling
+      if (event.type === 'touchstart' && !target.matches('.pipVal')) {
+        handleInteract(clientPos);
+      }
+    }
+  }
+
+  /**
+   * function to run when the user stops touching
+   * down on the slider element anywhere
+   * @param {event} e the event from browser
+   **/
+  function sliderInteractEnd(event: MouseEvent | TouchEvent) {
+    // fire the stop event for touch devices
+    if (event.type === 'touchend') {
+      eStop();
+    }
+    handlePressed = false;
+  }
+
+  /**
+   * unfocus the slider if the user clicked off of
+   * it, somewhere else on the screen
+   * @param {MouseEvent | TouchEvent} event the event from browser
+   **/
+  function bodyInteractStart(event: MouseEvent | TouchEvent) {
+    const target = event.target as Element;
+    keyboardActive = false;
+    if (slider && focus && target !== slider && !slider.contains(target)) {
+      focus = false;
+    }
+  }
+
+  /**
+   * send the clientX through to handle the interaction
+   * whenever the user moves acros screen while active
+   * @param {MouseEvent | TouchEvent} event the event from browser
+   **/
+  function bodyInteract(event: MouseEvent | TouchEvent) {
+    if (!disabled) {
+      if (handleActivated) {
+        handleInteract(normalisedClient(event));
+      }
+    }
+  }
+
+  /**
+   * if user triggers mouseup on the body while
+   * a handle is active (without moving) then we
+   * trigger an interact event there
+   * @param {event} event the event from browser
+   **/
+  function bodyMouseUp(event: MouseEvent) {
+    if (!disabled) {
+      const target = event.target as Element;
+      // this only works if a handle is active, which can
+      // only happen if there was sliderInteractStart triggered
+      // on the slider, already
+      if (handleActivated) {
+        if (slider && (target === slider || slider.contains(target))) {
+          focus = true;
+          // don't trigger interact if the target is a handle (no need) or
+          // if the target is a label (we want to move to that value from rangePips)
+          if (!targetIsHandle(target) && !target.matches('.pipVal')) {
+            handleInteract(normalisedClient(event));
+          }
+        }
+        // fire the stop event for mouse device
+        // when the body is triggered with an active handle
+        eStop();
+      }
+    }
+    handleActivated = false;
+    handlePressed = false;
+  }
+
+  /**
+   * if user triggers touchend on the body then we
+   * defocus the slider completely
+   * @param {event} event the event from browser
+   **/
+  function bodyTouchEnd(event: TouchEvent) {
+    handleActivated = false;
+    handlePressed = false;
+  }
+
+  function bodyKeyDown(event: KeyboardEvent) {
+    const target = event.target as Element;
+    if (!disabled && slider) {
+      if (target === slider || slider.contains(target)) {
+        keyboardActive = true;
+      }
+    }
+  }
+
+  function eStart() {
+    !disabled &&
+      dispatch('start', {
+        activeHandle,
+        value: startValue,
+        values: values.map((v) => alignValueToStep(v, min, max, step, precision))
+      });
+  }
+
+  function eStop() {
+    !disabled &&
+      dispatch('stop', {
+        activeHandle,
+        startValue: startValue,
+        value: values[activeHandle],
+        values: values.map((v) => alignValueToStep(v, min, max, step, precision))
+      });
+  }
+
+  function eChange() {
+    !disabled &&
+      dispatch('change', {
+        activeHandle,
+        startValue: startValue,
+        previousValue: typeof previousValue === 'undefined' ? startValue : previousValue,
+        value: values[activeHandle],
+        values: values.map((v) => alignValueToStep(v, min, max, step, precision))
+      });
+  }
+
+  function ariaLabelFormatter(value: number, index: number) {
+    const percent = valueAsPercent(value, min, max, precision);
+    const formattedValue = handleFormatter(value, index, percent);
+    const textLabel = pureText(String(formattedValue));
+    return `${prefix}${textLabel}${suffix}`;
+  }
 </script>
 
 <!-- svelte-ignore a11y-click-events-have-key-events -->
 <div
-	{id}
-	bind:this={slider}
-	role="none"
-	class="rangeSlider"
-	class:range
-	class:disabled
-	class:hoverable
-	class:vertical
-	class:reversed
-	class:focus
-	class:min={range === 'min'}
-	class:max={range === 'max'}
-	class:pips
-	class:pip-labels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}
-	on:mousedown={sliderInteractStart}
-	on:mouseup={sliderInteractEnd}
-	on:touchstart|preventDefault={sliderInteractStart}
-	on:touchend|preventDefault={sliderInteractEnd}
+  {id}
+  bind:this={slider}
+  role="none"
+  class="rangeSlider"
+  class:range
+  class:disabled
+  class:hoverable
+  class:vertical
+  class:reversed
+  class:focus
+  class:min={range === 'min'}
+  class:max={range === 'max'}
+  class:pips
+  class:pip-labels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}
+  on:mousedown={sliderInteractStart}
+  on:mouseup={sliderInteractEnd}
+  on:touchstart|preventDefault={sliderInteractStart}
+  on:touchend|preventDefault={sliderInteractEnd}
 >
-	{#each values as value, index}
-		{@const zindex = `z-index: ${activeHandle === index ? 3 : 2};`}
-		{@const handlePos = `${orientationStart}: ${$springPositions[index]}%;`}
-		<span
-			role="slider"
-			class="rangeHandle"
-			class:active={focus && activeHandle === index}
-			class:press={handlePressed && activeHandle === index}
-			data-handle={index}
-			on:blur={sliderBlurHandle}
-			on:focus={sliderFocusHandle}
-			on:keydown={sliderKeydown}
-			style="{handlePos} {zindex}"
-			aria-label={ariaLabels[index]}
-			aria-valuemin={range === true && index === 1 ? values[0] : min}
-			aria-valuemax={range === true && index === 0 ? values[1] : max}
-			aria-valuenow={value}
-			aria-valuetext={ariaLabelFormatter(value, index)}
-			aria-orientation={vertical ? 'vertical' : 'horizontal'}
-			aria-disabled={disabled}
-			tabindex={disabled ? -1 : 0}
-		>
-			<span class="rangeNub" />
-			{#if float}
-				{@const percent = valueAsPercent(value, min, max, precision)}
-				{@const formattedValue = handleFormatter(value, index, percent)}
-				<span class="rangeFloat">
-					{#if prefix}<span class="rangeFloat-prefix">{prefix}</span
-						>{/if}{@html formattedValue}{#if suffix}<span class="rangeFloat-suffix">{suffix}</span
-						>{/if}
-				</span>
-			{/if}
-		</span>
-	{/each}
-	{#if range}
-		<span
-			class="rangeBar"
-			style="{orientationStart}: {rangeStart($springPositions)}%; 
+  {#each values as value, index}
+    {@const zindex = `z-index: ${activeHandle === index ? 3 : 2};`}
+    {@const handlePos = `${orientationStart}: ${$springPositions[index]}%;`}
+    <span
+      role="slider"
+      class="rangeHandle"
+      class:active={focus && activeHandle === index}
+      class:press={handlePressed && activeHandle === index}
+      data-handle={index}
+      on:blur={sliderBlurHandle}
+      on:focus={sliderFocusHandle}
+      on:keydown={sliderKeydown}
+      style="{handlePos} {zindex}"
+      aria-label={ariaLabels[index]}
+      aria-valuemin={range === true && index === 1 ? values[0] : min}
+      aria-valuemax={range === true && index === 0 ? values[1] : max}
+      aria-valuenow={value}
+      aria-valuetext={ariaLabelFormatter(value, index)}
+      aria-orientation={vertical ? 'vertical' : 'horizontal'}
+      aria-disabled={disabled}
+      tabindex={disabled ? -1 : 0}
+    >
+      <span class="rangeNub" />
+      {#if float}
+        {@const percent = valueAsPercent(value, min, max, precision)}
+        {@const formattedValue = handleFormatter(value, index, percent)}
+        <span class="rangeFloat">
+          {#if prefix}<span class="rangeFloat-prefix">{prefix}</span
+            >{/if}{@html formattedValue}{#if suffix}<span class="rangeFloat-suffix">{suffix}</span
+            >{/if}
+        </span>
+      {/if}
+    </span>
+  {/each}
+  {#if range}
+    <span
+      class="rangeBar"
+      style="{orientationStart}: {rangeStart($springPositions)}%; 
              {orientationEnd}: {rangeEnd($springPositions)}%;"
-		/>
-	{/if}
-	{#if pips}
-		<RangePips
-			{values}
-			{min}
-			{max}
-			{step}
-			{range}
-			{vertical}
-			{reversed}
-			{orientationStart}
-			{hoverable}
-			{disabled}
-			{all}
-			{first}
-			{last}
-			{rest}
-			{pipstep}
-			{prefix}
-			{suffix}
-			{formatter}
-			{precision}
-			{focus}
-			{moveHandle}
-		/>
-	{/if}
+    />
+  {/if}
+  {#if pips}
+    <RangePips
+      {values}
+      {min}
+      {max}
+      {step}
+      {range}
+      {vertical}
+      {reversed}
+      {orientationStart}
+      {hoverable}
+      {disabled}
+      {all}
+      {first}
+      {last}
+      {rest}
+      {pipstep}
+      {prefix}
+      {suffix}
+      {formatter}
+      {precision}
+      {focus}
+      {moveHandle}
+    />
+  {/if}
 </div>
 
 <svelte:window
-	on:mousedown={bodyInteractStart}
-	on:touchstart={bodyInteractStart}
-	on:mousemove={bodyInteract}
-	on:touchmove={bodyInteract}
-	on:mouseup={bodyMouseUp}
-	on:touchend={bodyTouchEnd}
-	on:keydown={bodyKeyDown}
+  on:mousedown={bodyInteractStart}
+  on:touchstart={bodyInteractStart}
+  on:mousemove={bodyInteract}
+  on:touchmove={bodyInteract}
+  on:mouseup={bodyMouseUp}
+  on:touchend={bodyTouchEnd}
+  on:keydown={bodyKeyDown}
 />

commit 02759f86616501fc14922629292c38cf5b524099
Author: simeydotme <simey.me@gmail.com>
Date:   Mon Feb 5 00:00:07 2024 +0800

    add a pre-commit hook and prettier formatting

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index 105a76f..65c06b6 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -5,13 +5,9 @@
 		normalisedClient,
 		isInRange,
 		isSelected,
-		getValueFromIndex,
+		getValueFromIndex
 	} from '$lib/utils.js';
-	import type { 
-		Pip, 
-		Formatter, 
-		NormalisedClient 
-	} from '$lib/types.js';
+	import type { Pip, Formatter, NormalisedClient } from '$lib/types.js';
 
 	// range slider props
 	export let range: boolean | 'min' | 'max' = false;
@@ -35,7 +31,7 @@
 	// formatting props
 	export let prefix: string = '';
 	export let suffix: string = '';
-	export let formatter: Formatter = (v,i,p) => v;
+	export let formatter: Formatter = (v, i, p) => v;
 	export let precision: number = 2;
 
 	// stylistic props
@@ -112,25 +108,33 @@
 
 	{#if (all && rest !== false) || rest}
 		{#each Array(pipCount + 1) as _, i}
-			{#if getValueFromIndex(i,min,max,pipStep,step) !== min && getValueFromIndex(i,min,max,pipStep,step) !== max}
+			{#if getValueFromIndex(i, min, max, pipStep, step) !== min && getValueFromIndex(i, min, max, pipStep, step) !== max}
 				<span
 					class="pip"
-					class:selected={isSelected(getValueFromIndex(i,min,max,pipStep,step), values, precision)}
-					class:in-range={isInRange(getValueFromIndex(i,min,max,pipStep,step), values, range)}
-					style="{orientationStart}: {valueAsPercent(getValueFromIndex(i,min,max,pipStep,step), min, max)}%;"
+					class:selected={isSelected(
+						getValueFromIndex(i, min, max, pipStep, step),
+						values,
+						precision
+					)}
+					class:in-range={isInRange(getValueFromIndex(i, min, max, pipStep, step), values, range)}
+					style="{orientationStart}: {valueAsPercent(
+						getValueFromIndex(i, min, max, pipStep, step),
+						min,
+						max
+					)}%;"
 					on:pointerdown={(e) => {
 						labelDown(e);
 					}}
 					on:pointerup={(e) => {
-						labelUp(getValueFromIndex(i,min,max,pipStep,step), e);
+						labelUp(getValueFromIndex(i, min, max, pipStep, step), e);
 					}}
 				>
 					{#if all === 'label' || rest === 'label'}
 						<span class="pipVal">
 							{#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
-								getValueFromIndex(i,min,max,pipStep,step),
+								getValueFromIndex(i, min, max, pipStep, step),
 								i,
-								valueAsPercent(getValueFromIndex(i,min,max,pipStep,step), min, max, precision)
+								valueAsPercent(getValueFromIndex(i, min, max, pipStep, step), min, max, precision)
 							)}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
 						</span>
 					{/if}
@@ -163,4 +167,4 @@
 			{/if}
 		</span>
 	{/if}
-</div>
\ No newline at end of file
+</div>
diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 88b7b51..9fe53ba 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -9,13 +9,9 @@
 		alignValueToStep,
 		pureText,
 		normalisedClient,
-		elementIndex,
+		elementIndex
 	} from '$lib/utils.js';
-	import type { 
-		Pip, 
-		Formatter, 
-		NormalisedClient 
-	} from '$lib/types.js';
+	import type { Pip, Formatter, NormalisedClient } from '$lib/types.js';
 
 	import RangePips from './RangePips.svelte';
 

commit f2f8503c745814a067b69e227bd18a0b1bd30208
Author: simeydotme <simey.me@gmail.com>
Date:   Sun Feb 4 23:29:00 2024 +0800

    update build options

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
index 2faa77e..105a76f 100644
--- a/src/lib/components/RangePips.svelte
+++ b/src/lib/components/RangePips.svelte
@@ -6,10 +6,12 @@
 		isInRange,
 		isSelected,
 		getValueFromIndex,
-		type NormalisedClient,
-		type Formatter,
-		type Pip
-	} from '$lib/index.js';
+	} from '$lib/utils.js';
+	import type { 
+		Pip, 
+		Formatter, 
+		NormalisedClient 
+	} from '$lib/types.js';
 
 	// range slider props
 	export let range: boolean | 'min' | 'max' = false;
diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
index 113d5b8..88b7b51 100644
--- a/src/lib/components/RangeSlider.svelte
+++ b/src/lib/components/RangeSlider.svelte
@@ -10,10 +10,12 @@
 		pureText,
 		normalisedClient,
 		elementIndex,
-		type NormalisedClient,
-		type Formatter,
-		type Pip
-	} from '$lib/index.js';
+	} from '$lib/utils.js';
+	import type { 
+		Pip, 
+		Formatter, 
+		NormalisedClient 
+	} from '$lib/types.js';
 
 	import RangePips from './RangePips.svelte';
 

commit 118cddb0b2fa14e07d0cde13eec86b006b3704d0
Author: simeydotme <simey.me@gmail.com>
Date:   Sun Feb 4 02:15:55 2024 +0800

    add first files for new sveltekit library version

diff --git a/src/lib/components/RangePips.svelte b/src/lib/components/RangePips.svelte
new file mode 100644
index 0000000..2faa77e
--- /dev/null
+++ b/src/lib/components/RangePips.svelte
@@ -0,0 +1,164 @@
+<script lang="ts">
+	import {
+		coerceFloat,
+		valueAsPercent,
+		normalisedClient,
+		isInRange,
+		isSelected,
+		getValueFromIndex,
+		type NormalisedClient,
+		type Formatter,
+		type Pip
+	} from '$lib/index.js';
+
+	// range slider props
+	export let range: boolean | 'min' | 'max' = false;
+	export let min: number = 0;
+	export let max: number = 100;
+	export let step: number = 1;
+	export let value: number = (max + min) / 2;
+	export let values: number[] = [value];
+	export let vertical: boolean = false;
+	export let reversed: boolean = false;
+	export let hoverable: boolean = true;
+	export let disabled: boolean = false;
+
+	// range pips / values props
+	export let pipstep: number | undefined = undefined;
+	export let all: Pip = true;
+	export let first: Pip = undefined;
+	export let last: Pip = undefined;
+	export let rest: Pip = undefined;
+
+	// formatting props
+	export let prefix: string = '';
+	export let suffix: string = '';
+	export let formatter: Formatter = (v,i,p) => v;
+	export let precision: number = 2;
+
+	// stylistic props
+	export let focus: boolean;
+	export let orientationStart: string;
+
+	// methods
+	export let moveHandle: (index: number | null, value: number) => void;
+
+	let clientStart: null | NormalisedClient = null;
+
+	$: stepMax = vertical ? 50 : 100;
+	$: tooManyPips = (max - min) / step >= stepMax;
+	$: stepDivisor = vertical ? 10 : 20;
+	$: reducedSteps = (max - min) / stepDivisor;
+	$: pipStep = pipstep ?? (tooManyPips ? reducedSteps : 1);
+	$: pipCount = Math.floor((max - min) / (step * pipStep));
+
+	/**
+	 * function to run when the user clicks on a label
+	 * we store the original client position so we can check if the user has moved the mouse/finger
+	 * @param {event} event the event from browser
+	 **/
+	function labelDown(event: PointerEvent) {
+		clientStart = normalisedClient(event);
+	}
+
+	/**
+	 * function to run when the user releases the mouse/finger
+	 * we check if the user has moved the mouse/finger, if not we "click" the label
+	 * and move the handle it to the label position
+	 * @param {number} pipValue the value of the label
+	 * @param {event} e the event from browser
+	 */
+	function labelUp(pipValue: number, event: PointerEvent) {
+		const clientEnd = normalisedClient(event);
+		if (!disabled && clientStart) {
+			const distanceMoved = Math.sqrt(
+				Math.pow(clientStart.x - clientEnd.x, 2) + Math.pow(clientStart.y - clientEnd.y, 2)
+			);
+			if (distanceMoved <= 5) {
+				moveHandle(null, pipValue);
+			}
+			clientStart = null;
+		}
+	}
+</script>
+
+<div class="rangePips" class:disabled class:hoverable class:vertical class:reversed class:focus>
+	{#if (all && first !== false) || first}
+		<span
+			class="pip first"
+			class:selected={isSelected(min, values, precision)}
+			class:in-range={isInRange(min, values, range)}
+			style="{orientationStart}: 0%;"
+			on:pointerdown={(e) => {
+				labelDown(e);
+			}}
+			on:pointerup={(e) => {
+				labelUp(min, e);
+			}}
+		>
+			{#if all === 'label' || first === 'label'}
+				<span class="pipVal">
+					{#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
+						coerceFloat(min),
+						0,
+						0
+					)}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+				</span>
+			{/if}
+		</span>
+	{/if}
+
+	{#if (all && rest !== false) || rest}
+		{#each Array(pipCount + 1) as _, i}
+			{#if getValueFromIndex(i,min,max,pipStep,step) !== min && getValueFromIndex(i,min,max,pipStep,step) !== max}
+				<span
+					class="pip"
+					class:selected={isSelected(getValueFromIndex(i,min,max,pipStep,step), values, precision)}
+					class:in-range={isInRange(getValueFromIndex(i,min,max,pipStep,step), values, range)}
+					style="{orientationStart}: {valueAsPercent(getValueFromIndex(i,min,max,pipStep,step), min, max)}%;"
+					on:pointerdown={(e) => {
+						labelDown(e);
+					}}
+					on:pointerup={(e) => {
+						labelUp(getValueFromIndex(i,min,max,pipStep,step), e);
+					}}
+				>
+					{#if all === 'label' || rest === 'label'}
+						<span class="pipVal">
+							{#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
+								getValueFromIndex(i,min,max,pipStep,step),
+								i,
+								valueAsPercent(getValueFromIndex(i,min,max,pipStep,step), min, max, precision)
+							)}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+						</span>
+					{/if}
+				</span>
+			{/if}
+		{/each}
+	{/if}
+
+	{#if (all && last !== false) || last}
+		<span
+			class="pip last"
+			class:selected={isSelected(max, values, precision)}
+			class:in-range={isInRange(max, values, range)}
+			style="{orientationStart}: 100%;"
+			on:pointerdown={(e) => {
+				labelDown(e);
+			}}
+			on:pointerup={(e) => {
+				labelUp(max, e);
+			}}
+		>
+			{#if all === 'label' || last === 'label'}
+				<span class="pipVal">
+					{#if prefix}<span class="pipVal-prefix">{prefix}</span>{/if}{@html formatter(
+						coerceFloat(max),
+						pipCount,
+						100
+					)}{#if suffix}<span class="pipVal-suffix">{suffix}</span>{/if}
+				</span>
+			{/if}
+		</span>
+	{/if}
+</div>
\ No newline at end of file
diff --git a/src/lib/components/RangeSlider.svelte b/src/lib/components/RangeSlider.svelte
new file mode 100644
index 0000000..113d5b8
--- /dev/null
+++ b/src/lib/components/RangeSlider.svelte
@@ -0,0 +1,685 @@
+<script lang="ts">
+	import './RangeSlider.css';
+	import { type SpringOpts, type Spring, spring } from 'svelte/motion';
+	import { createEventDispatcher } from 'svelte';
+	import {
+		coerceFloat,
+		valueAsPercent,
+		clampValue,
+		alignValueToStep,
+		pureText,
+		normalisedClient,
+		elementIndex,
+		type NormalisedClient,
+		type Formatter,
+		type Pip
+	} from '$lib/index.js';
+
+	import RangePips from './RangePips.svelte';
+
+	// dom references
+	export let slider: HTMLDivElement | undefined = undefined;
+
+	// range slider props
+	export let range: boolean | 'min' | 'max' = false;
+	export let pushy: boolean = false;
+	export let min: number = 0;
+	export let max: number = 100;
+	export let step: number = 1;
+	export let values: number[] = [(max + min) / 2];
+	export let value: number = values[0];
+	export let vertical: boolean = false;
+	export let float: boolean = false;
+	export let reversed: boolean = false;
+	export let hoverable: boolean = true;
+	export let disabled: boolean = false;
+
+	// range pips / values props
+	export let pips: boolean = false;
+	export let pipstep: number | undefined = undefined;
+	export let all: Pip = true;
+	export let first: Pip = undefined;
+	export let last: Pip = undefined;
+	export let rest: Pip = undefined;
+
+	// formatting props
+	export let id: string | undefined = undefined;
+	export let prefix: string = '';
+	export let suffix: string = '';
+	export let formatter: Formatter = (v, i, p) => v;
+	export let handleFormatter = formatter;
+	export let ariaLabels: string[] = [];
+
+	// stylistic props
+	export let precision: number = 2;
+	export let springValues: SpringOpts = { stiffness: 0.15, damping: 0.4 };
+
+	// prepare dispatched events
+	const dispatch = createEventDispatcher();
+
+	// state management
+	let valueLength = 0;
+	let focus = false;
+	let handleActivated = false;
+	let handlePressed = false;
+	let keyboardActive = false;
+	let activeHandle = values.length - 1;
+	let startValue: number;
+	let previousValue: number;
+
+	// copy the initial values in to a spring function which
+	// will update every time the values array is modified
+	let springPositions: Spring<number[]>;
+
+	// check that "values" is an array, or set it as array
+	const updateValues = () => {
+		checkValuesIsArray();
+		// sync values with value
+		if (values[0] !== value) {
+			values[0] = value;
+		}
+	};
+
+	// check that "value" is a number, or set it as the average
+	const updateValue = () => {
+		checkValueIsNumber();
+		// sync value with values
+		if (value !== values[0]) {
+			value = values[0];
+		}
+	};
+
+	const checkValueIsNumber = () => {
+		if (typeof value !== 'number') {
+			value = (max + min) / 2;
+			console.error("'value' prop should be a Number");
+		}
+	};
+
+	const checkValuesIsArray = () => {
+		if (!Array.isArray(values)) {
+			values = [value];
+			console.error("'values' prop should be an Array");
+		}
+	};
+
+	const checkAriaLabels = () => {
+		if (values.length > 1 && !Array.isArray(ariaLabels)) {
+			console.warn(`'ariaLabels' prop should be an Array`);
+		}
+	};
+
+	// fixup the value/values at render
+	checkValueIsNumber();
+	checkValuesIsArray();
+
+	// keep value and values in sync with each other
+	$: value, updateValues();
+	$: values, updateValue();
+	$: ariaLabels, checkAriaLabels();
+
+	$: {
+		// trim the range so it remains as a min/max (only 2 handles)
+		// and also align the handles to the steps
+		const trimmedAlignedValues = trimRange(
+			values.map((v) => alignValueToStep(v, min, max, step, precision))
+		);
+		if (
+			!(values.length === trimmedAlignedValues.length) ||
+			!values.every(
+				(element, index) => coerceFloat(element, precision) === trimmedAlignedValues[index]
+			)
+		) {
+			values = trimmedAlignedValues;
+		}
+
+		// check if the valueLength (length of values[]) has changed,
+		// because if so we need to re-seed the spring function with the
+		// new values array.
+		if (valueLength !== values.length) {
+			// set the initial spring values when the slider initialises,
+			// or when values array length has changed
+			springPositions = spring(
+				values.map((v) => valueAsPercent(v, min, max)),
+				springValues
+			);
+		} else {
+			// update the value of the spring function for animated handles
+			// whenever the values has updated
+			springPositions.set(values.map((v) => valueAsPercent(v, min, max)));
+		}
+		// set the valueLength for the next check
+		valueLength = values.length;
+	}
+
+	/**
+	 * the orientation of the handles/pips based on the
+	 * input values of vertical and reversed
+	 **/
+	$: orientationStart = vertical ? (reversed ? 'top' : 'bottom') : reversed ? 'right' : 'left';
+	$: orientationEnd = vertical ? (reversed ? 'bottom' : 'top') : reversed ? 'left' : 'right';
+
+	/**
+	 * check if an element is a handle on the slider
+	 * @param {object} el dom object reference we want to check
+	 * @returns {boolean}
+	 **/
+	function targetIsHandle(el: Element) {
+		if (!slider) return false;
+		const handles = slider.querySelectorAll('.handle');
+		const isHandle = Array.prototype.includes.call(handles, el);
+		const isChild = Array.prototype.some.call(handles, (e) => e.contains(el));
+		return isHandle || isChild;
+	}
+
+	/**
+	 * trim the values array based on whether the property
+	 * for 'range' is 'min', 'max', or truthy. This is because we
+	 * do not want more than one handle for a min/max range, and we do
+	 * not want more than two handles for a true range.
+	 * @param {array} values the input values for the rangeSlider
+	 * @return {array} the range array for creating a rangeSlider
+	 **/
+	function trimRange(values: number[]) {
+		if (range === 'min' || range === 'max') {
+			return values.slice(0, 1);
+		} else if (range) {
+			return values.slice(0, 2);
+		} else {
+			return values;
+		}
+	}
+
+	/**
+	 * helper to return closest handle to user interaction
+	 * @param {object} clientPos the client {x,y} positions to check against
+	 * @return {number} the index of the closest handle to clientPos
+	 **/
+	function getClosestHandle(clientPos: NormalisedClient) {
+		if (!slider) return 0;
+		// first make sure we have the latest dimensions
+		// of the slider, as it may have changed size
+		const dims = slider.getBoundingClientRect();
+		// calculate the interaction position, percent and value
+		let handlePos = 0;
+		let handlePercent = 0;
+		let handleVal = 0;
+		if (vertical) {
+			handlePos = clientPos.y - dims.top;
+			handlePercent = (handlePos / dims.height) * 100;
+			handlePercent = reversed ? handlePercent : 100 - handlePercent;
+		} else {
+			handlePos = clientPos.x - dims.left;
+			handlePercent = (handlePos / dims.width) * 100;
+			handlePercent = reversed ? 100 - handlePercent : handlePercent;
+		}
+		handleVal = ((max - min) / 100) * handlePercent + min;
+
+		let closest;
+
+		// if we have a range, and the handles are at the same
+		// position, we want a simple check if the interaction
+		// value is greater than return the second handle
+		if (range === true && values[0] === values[1]) {
+			if (handleVal > values[1]) {
+				return 1;
+			} else {
+				return 0;
+			}
+			// if there are multiple handles, and not a range, then
+			// we sort the handles values, and return the first one closest
+			// to the interaction value
+		} else {
+			closest = values.indexOf(
+				[...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]
+			);
+		}
+		return closest;
+	}
+
+	/**
+	 * take the interaction position on the slider, convert
+	 * it to a value on the range, and then send that value
+	 * through to the moveHandle() method to set the active
+	 * handle's position
+	 * @param {object} clientPos the client {x,y} of the interaction
+	 **/
+	function handleInteract(clientPos: NormalisedClient) {
+		if (!slider) return;
+		// first make sure we have the latest dimensions
+		// of the slider, as it may have changed size
+		const dims = slider.getBoundingClientRect();
+		// calculate the interaction position, percent and value
+		let handlePos = 0;
+		let handlePercent = 0;
+		let handleVal = 0;
+		if (vertical) {
+			handlePos = clientPos.y - dims.top;
+			handlePercent = (handlePos / dims.height) * 100;
+			handlePercent = reversed ? handlePercent : 100 - handlePercent;
+		} else {
+			handlePos = clientPos.x - dims.left;
+			handlePercent = (handlePos / dims.width) * 100;
+			handlePercent = reversed ? 100 - handlePercent : handlePercent;
+		}
+		handleVal = ((max - min) / 100) * handlePercent + min;
+		// move handle to the value
+		moveHandle(activeHandle, handleVal);
+	}
+
+	/**
+	 * move a handle to a specific value, respecting the clamp/align rules
+	 * @param {number} index the index of the handle we want to move
+	 * @param {number} value the value to move the handle to
+	 * @return {number} the value that was moved to (after alignment/clamping)
+	 **/
+	function moveHandle(index: number | null, value: number) {
+		// align & clamp the value so we're not doing extra
+		// calculation on an out-of-range value down below
+		value = alignValueToStep(value, min, max, step, precision);
+		// use the active handle if handle index is not provided
+		if (index === null) {
+			index = activeHandle;
+		}
+		// if this is a range slider perform special checks
+		if (range) {
+			// restrict the handles of a range-slider from
+			// going past one-another unless "pushy" is true
+			if (index === 0 && value > values[1]) {
+				if (pushy) {
+					values[1] = value;
+				} else {
+					value = values[1];
+				}
+			} else if (index === 1 && value < values[0]) {
+				if (pushy) {
+					values[0] = value;
+				} else {
+					value = values[0];
+				}
+			}
+		}
+
+		// if the value has changed, update it
+		if (values[index] !== value) {
+			values[index] = value;
+		}
+
+		// fire the change event when the handle moves,
+		// and store the previous value for the next time
+		if (previousValue !== value) {
+			eChange();
+			previousValue = value;
+		}
+		return value;
+	}
+
+	/**
+	 * helper to find the beginning range value for use with css style
+	 * @param {array} values the input values for the rangeSlider
+	 * @return {number} the beginning of the range
+	 **/
+	function rangeStart(values: number[]) {
+		if (range === 'min') {
+			return 0;
+		} else {
+			return values[0];
+		}
+	}
+
+	/**
+	 * helper to find the ending range value for use with css style
+	 * @param {array} values the input values for the rangeSlider
+	 * @return {number} the end of the range
+	 **/
+	function rangeEnd(values: number[]) {
+		if (range === 'max') {
+			return 0;
+		} else if (range === 'min') {
+			return 100 - values[0];
+		} else {
+			return 100 - values[1];
+		}
+	}
+
+	/**
+	 * when the user has unfocussed (blurred) from the
+	 * slider, deactivate all handles
+	 * @param {FocusEvent} event the event from browser
+	 **/
+	function sliderBlurHandle(event: FocusEvent) {
+		const target = event.target as HTMLSpanElement;
+		if (keyboardActive) {
+			focus = false;
+			handleActivated = false;
+			handlePressed = false;
+		}
+	}
+
+	/**
+	 * when the user focusses the handle of a slider
+	 * set it to be active
+	 * @param {FocusEvent} event the event from browser
+	 **/
+	function sliderFocusHandle(event: FocusEvent) {
+		const target = event.target as HTMLSpanElement;
+		if (!disabled) {
+			activeHandle = elementIndex(target);
+			focus = true;
+		}
+	}
+
+	/**
+	 * handle the keyboard accessible features by checking the
+	 * input type, and modfier key then moving handle by appropriate amount
+	 * @param {KeyboardEvent} event the event from browser
+	 **/
+	function sliderKeydown(event: KeyboardEvent) {
+		if (!disabled) {
+			let prevent = false;
+			const handle = elementIndex(event.target as HTMLSpanElement);
+			let jump = step;
+			if (event.ctrlKey || event.metaKey) {
+				jump = clampValue(
+					(max - min) / step / 100,
+					coerceFloat(jump, precision),
+					coerceFloat((max - min) / 100, precision)
+				);
+				// ~ 1%
+			} else if (event.shiftKey) {
+				// ~ 10%
+				jump = clampValue(
+					(max - min) / step / 10,
+					coerceFloat(jump, precision),
+					coerceFloat((max - min) / 10, precision)
+				);
+			}
+
+			switch (event.key) {
+				case 'PageDown':
+					jump *= 10;
+				case 'ArrowRight':
+				case 'ArrowUp':
+					moveHandle(handle, values[handle] + coerceFloat(jump, precision));
+					prevent = true;
+					break;
+				case 'PageUp':
+					jump *= 10;
+				case 'ArrowLeft':
+				case 'ArrowDown':
+					moveHandle(handle, values[handle] - coerceFloat(jump, precision));
+					prevent = true;
+					break;
+				case 'Home':
+					moveHandle(handle, min);
+					prevent = true;
+					break;
+				case 'End':
+					moveHandle(handle, max);
+					prevent = true;
+					break;
+			}
+			if (prevent) {
+				event.preventDefault();
+				event.stopPropagation();
+			}
+		}
+	}
+
+	/**
+	 * function to run when the user touches
+	 * down on the slider element anywhere
+	 * @param {MouseEvent | TouchEvent} event the event from browser
+	 **/
+	function sliderInteractStart(event: MouseEvent | TouchEvent) {
+		if (!disabled) {
+			const target = event.target as Element;
+			const clientPos = normalisedClient(event);
+			// set the closest handle as active
+			focus = true;
+			handleActivated = true;
+			handlePressed = true;
+			activeHandle = getClosestHandle(clientPos);
+
+			// fire the start event
+			startValue = previousValue = alignValueToStep(
+				values[activeHandle],
+				min,
+				max,
+				step,
+				precision
+			);
+			eStart();
+
+			// for touch devices we want the handle to instantly
+			// move to the position touched for more responsive feeling
+			if (event.type === 'touchstart' && !target.matches('.pipVal')) {
+				handleInteract(clientPos);
+			}
+		}
+	}
+
+	/**
+	 * function to run when the user stops touching
+	 * down on the slider element anywhere
+	 * @param {event} e the event from browser
+	 **/
+	function sliderInteractEnd(event: MouseEvent | TouchEvent) {
+		// fire the stop event for touch devices
+		if (event.type === 'touchend') {
+			eStop();
+		}
+		handlePressed = false;
+	}
+
+	/**
+	 * unfocus the slider if the user clicked off of
+	 * it, somewhere else on the screen
+	 * @param {MouseEvent | TouchEvent} event the event from browser
+	 **/
+	function bodyInteractStart(event: MouseEvent | TouchEvent) {
+		const target = event.target as Element;
+		keyboardActive = false;
+		if (slider && focus && target !== slider && !slider.contains(target)) {
+			focus = false;
+		}
+	}
+
+	/**
+	 * send the clientX through to handle the interaction
+	 * whenever the user moves acros screen while active
+	 * @param {MouseEvent | TouchEvent} event the event from browser
+	 **/
+	function bodyInteract(event: MouseEvent | TouchEvent) {
+		if (!disabled) {
+			if (handleActivated) {
+				handleInteract(normalisedClient(event));
+			}
+		}
+	}
+
+	/**
+	 * if user triggers mouseup on the body while
+	 * a handle is active (without moving) then we
+	 * trigger an interact event there
+	 * @param {event} event the event from browser
+	 **/
+	function bodyMouseUp(event: MouseEvent) {
+		if (!disabled) {
+			const target = event.target as Element;
+			// this only works if a handle is active, which can
+			// only happen if there was sliderInteractStart triggered
+			// on the slider, already
+			if (handleActivated) {
+				if (slider && (target === slider || slider.contains(target))) {
+					focus = true;
+					// don't trigger interact if the target is a handle (no need) or
+					// if the target is a label (we want to move to that value from rangePips)
+					if (!targetIsHandle(target) && !target.matches('.pipVal')) {
+						handleInteract(normalisedClient(event));
+					}
+				}
+				// fire the stop event for mouse device
+				// when the body is triggered with an active handle
+				eStop();
+			}
+		}
+		handleActivated = false;
+		handlePressed = false;
+	}
+
+	/**
+	 * if user triggers touchend on the body then we
+	 * defocus the slider completely
+	 * @param {event} event the event from browser
+	 **/
+	function bodyTouchEnd(event: TouchEvent) {
+		handleActivated = false;
+		handlePressed = false;
+	}
+
+	function bodyKeyDown(event: KeyboardEvent) {
+		const target = event.target as Element;
+		if (!disabled && slider) {
+			if (target === slider || slider.contains(target)) {
+				keyboardActive = true;
+			}
+		}
+	}
+
+	function eStart() {
+		!disabled &&
+			dispatch('start', {
+				activeHandle,
+				value: startValue,
+				values: values.map((v) => alignValueToStep(v, min, max, step, precision))
+			});
+	}
+
+	function eStop() {
+		!disabled &&
+			dispatch('stop', {
+				activeHandle,
+				startValue: startValue,
+				value: values[activeHandle],
+				values: values.map((v) => alignValueToStep(v, min, max, step, precision))
+			});
+	}
+
+	function eChange() {
+		!disabled &&
+			dispatch('change', {
+				activeHandle,
+				startValue: startValue,
+				previousValue: typeof previousValue === 'undefined' ? startValue : previousValue,
+				value: values[activeHandle],
+				values: values.map((v) => alignValueToStep(v, min, max, step, precision))
+			});
+	}
+
+	function ariaLabelFormatter(value: number, index: number) {
+		const percent = valueAsPercent(value, min, max, precision);
+		const formattedValue = handleFormatter(value, index, percent);
+		const textLabel = pureText(String(formattedValue));
+		return `${prefix}${textLabel}${suffix}`;
+	}
+</script>
+
+<!-- svelte-ignore a11y-click-events-have-key-events -->
+<div
+	{id}
+	bind:this={slider}
+	role="none"
+	class="rangeSlider"
+	class:range
+	class:disabled
+	class:hoverable
+	class:vertical
+	class:reversed
+	class:focus
+	class:min={range === 'min'}
+	class:max={range === 'max'}
+	class:pips
+	class:pip-labels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}
+	on:mousedown={sliderInteractStart}
+	on:mouseup={sliderInteractEnd}
+	on:touchstart|preventDefault={sliderInteractStart}
+	on:touchend|preventDefault={sliderInteractEnd}
+>
+	{#each values as value, index}
+		{@const zindex = `z-index: ${activeHandle === index ? 3 : 2};`}
+		{@const handlePos = `${orientationStart}: ${$springPositions[index]}%;`}
+		<span
+			role="slider"
+			class="rangeHandle"
+			class:active={focus && activeHandle === index}
+			class:press={handlePressed && activeHandle === index}
+			data-handle={index}
+			on:blur={sliderBlurHandle}
+			on:focus={sliderFocusHandle}
+			on:keydown={sliderKeydown}
+			style="{handlePos} {zindex}"
+			aria-label={ariaLabels[index]}
+			aria-valuemin={range === true && index === 1 ? values[0] : min}
+			aria-valuemax={range === true && index === 0 ? values[1] : max}
+			aria-valuenow={value}
+			aria-valuetext={ariaLabelFormatter(value, index)}
+			aria-orientation={vertical ? 'vertical' : 'horizontal'}
+			aria-disabled={disabled}
+			tabindex={disabled ? -1 : 0}
+		>
+			<span class="rangeNub" />
+			{#if float}
+				{@const percent = valueAsPercent(value, min, max, precision)}
+				{@const formattedValue = handleFormatter(value, index, percent)}
+				<span class="rangeFloat">
+					{#if prefix}<span class="rangeFloat-prefix">{prefix}</span
+						>{/if}{@html formattedValue}{#if suffix}<span class="rangeFloat-suffix">{suffix}</span
+						>{/if}
+				</span>
+			{/if}
+		</span>
+	{/each}
+	{#if range}
+		<span
+			class="rangeBar"
+			style="{orientationStart}: {rangeStart($springPositions)}%; 
+             {orientationEnd}: {rangeEnd($springPositions)}%;"
+		/>
+	{/if}
+	{#if pips}
+		<RangePips
+			{values}
+			{min}
+			{max}
+			{step}
+			{range}
+			{vertical}
+			{reversed}
+			{orientationStart}
+			{hoverable}
+			{disabled}
+			{all}
+			{first}
+			{last}
+			{rest}
+			{pipstep}
+			{prefix}
+			{suffix}
+			{formatter}
+			{precision}
+			{focus}
+			{moveHandle}
+		/>
+	{/if}
+</div>
+
+<svelte:window
+	on:mousedown={bodyInteractStart}
+	on:touchstart={bodyInteractStart}
+	on:mousemove={bodyInteract}
+	on:touchmove={bodyInteract}
+	on:mouseup={bodyMouseUp}
+	on:touchend={bodyTouchEnd}
+	on:keydown={bodyKeyDown}
+/>
